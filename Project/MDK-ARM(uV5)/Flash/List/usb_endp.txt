; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_endp.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_endp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -I..\..\User\Algorithm\ekf2 -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usb_endp.crf ..\..\User\usb_virture_com\usb_endp.c]
                          THUMB

                          AREA ||i.EP1_IN_Callback||, CODE, READONLY, ALIGN=2

                  EP1_IN_Callback PROC
;;;42     */
;;;43     void EP1_IN_Callback (void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;44     {
;;;45     	/*
;;;46     	为了提高传输效率，并且方便FIFO操作，将 UserToPMABufferCopy() 函数就地展开 
;;;47     	void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
;;;48     	{
;;;49     	  uint32_t n = (wNBytes + 1) >> 1;
;;;50     	  uint32_t i, temp1, temp2;
;;;51     	  uint16_t *pdwVal;
;;;52     	  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
;;;53     	  for (i = n; i != 0; i--)
;;;54     	  {
;;;55     	    temp1 = (uint16_t) * pbUsrBuf;
;;;56     	    pbUsrBuf++;
;;;57     	    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
;;;58     	    *pdwVal++ = temp2;
;;;59     	    pdwVal++;
;;;60     	    pbUsrBuf++;
;;;61     	  }
;;;62     	}		
;;;63     	*/
;;;64     	uint16_t i;
;;;65     	uint16_t usWord;
;;;66     	uint8_t ucByteNum;
;;;67     	uint16_t *pdwVal;
;;;68     	uint16_t usTotalSize;
;;;69     	
;;;70     	usTotalSize = 0;
000002  2600              MOVS     r6,#0
;;;71     	pdwVal = (uint16_t *)(ENDP1_TXADDR * 2 + PMAAddr);	
000004  4d10              LDR      r5,|L1.72|
;;;72     	for (i = 0 ; i < VIRTUAL_COM_PORT_DATA_SIZE / 2; i++)
000006  2700              MOVS     r7,#0
000008  e010              B        |L1.44|
                  |L1.10|
;;;73     	{
;;;74     		usWord = usb_GetTxWord(&ucByteNum);
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       usb_GetTxWord
000010  4604              MOV      r4,r0
;;;75     		if (ucByteNum == 0)
000012  f89d0000          LDRB     r0,[sp,#0]
000016  b900              CBNZ     r0,|L1.26|
;;;76     		{
;;;77     			break;
000018  e00a              B        |L1.48|
                  |L1.26|
;;;78     		}
;;;79     		
;;;80     		usTotalSize += ucByteNum;
00001a  f89d0000          LDRB     r0,[sp,#0]
00001e  4430              ADD      r0,r0,r6
000020  b286              UXTH     r6,r0
;;;81     		
;;;82     		*pdwVal++ = usWord;
000022  f8254b02          STRH     r4,[r5],#2
;;;83     		pdwVal++;		
000026  1cad              ADDS     r5,r5,#2
000028  1c78              ADDS     r0,r7,#1              ;72
00002a  b287              UXTH     r7,r0                 ;72
                  |L1.44|
00002c  2f20              CMP      r7,#0x20              ;72
00002e  dbec              BLT      |L1.10|
                  |L1.48|
000030  bf00              NOP                            ;77
;;;84     
;;;85     		/*
;;;86     			STM32的USB缓冲区是一个双端口的RAM，CPU一端需要使用32位方式访问，但USB模块一端使用16位方式访问。
;;;87     			也就是说每个USB模块中的地址*2才能对应到控制器中的实际地址，这样每四个字节地址空间后两个字节
;;;88     			地址空间是空的
;;;89     		*/
;;;90     	}
;;;91     	
;;;92     	if (usTotalSize == 0)
000032  b906              CBNZ     r6,|L1.54|
                  |L1.52|
;;;93     	{
;;;94     		return;
;;;95     	}
;;;96     	
;;;97     	SetEPTxCount(ENDP1, usTotalSize);
;;;98     	SetEPTxValid(ENDP1); 
;;;99     }
000034  bdf8              POP      {r3-r7,pc}
                  |L1.54|
000036  4631              MOV      r1,r6                 ;97
000038  2001              MOVS     r0,#1                 ;97
00003a  f7fffffe          BL       SetEPTxCount
00003e  2001              MOVS     r0,#1                 ;98
000040  f7fffffe          BL       SetEPTxValid
000044  bf00              NOP      
000046  e7f5              B        |L1.52|
;;;100    
                          ENDP

                  |L1.72|
                          DCD      0x40006180

                          AREA ||i.EP3_OUT_Callback||, CODE, READONLY, ALIGN=1

                  EP3_OUT_Callback PROC
;;;108    */
;;;109    void EP3_OUT_Callback(void)
000000  b510              PUSH     {r4,lr}
;;;110    {
000002  b090              SUB      sp,sp,#0x40
;;;111    	uint16_t usRxCnt;
;;;112    	uint8_t USB_Rx_Buffer[VIRTUAL_COM_PORT_DATA_SIZE];
;;;113    	
;;;114    	/* 将USB端点3收到的数据存储到USB_Rx_Buffer， 数据大小保存在USB_Rx_Cnt */
;;;115    	usRxCnt = USB_SIL_Read(EP3_OUT, USB_Rx_Buffer);
000004  4669              MOV      r1,sp
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       USB_SIL_Read
00000c  b284              UXTH     r4,r0
;;;116    	
;;;117    	/* 立即将接收到的数据缓存到内存 */
;;;118    	usb_SaveHostDataToBuf(USB_Rx_Buffer, usRxCnt);
00000e  4621              MOV      r1,r4
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       usb_SaveHostDataToBuf
;;;119    	
;;;120    	/* 允许 EP3 端点接收数据 */
;;;121    	SetEPRxValid(ENDP3);
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       SetEPRxValid
;;;122    }
00001c  b010              ADD      sp,sp,#0x40
00001e  bd10              POP      {r4,pc}
;;;123    
                          ENDP


                          AREA ||i.SOF_Callback||, CODE, READONLY, ALIGN=2

                  SOF_Callback PROC
;;;131    */
;;;132    void SOF_Callback(void)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134    	static uint32_t FrameCount = 0;
;;;135    	
;;;136    	if (bDeviceState == CONFIGURED)
000002  4809              LDR      r0,|L3.40|
000004  6800              LDR      r0,[r0,#0]  ; bDeviceState
000006  2805              CMP      r0,#5
000008  d10c              BNE      |L3.36|
;;;137    	{
;;;138    		if (FrameCount++ == VCOMPORT_IN_FRAME_INTERVAL)
00000a  4808              LDR      r0,|L3.44|
00000c  6801              LDR      r1,[r0,#0]  ; FrameCount
00000e  6800              LDR      r0,[r0,#0]  ; FrameCount
000010  1c40              ADDS     r0,r0,#1
000012  4a06              LDR      r2,|L3.44|
000014  6010              STR      r0,[r2,#0]  ; FrameCount
000016  2905              CMP      r1,#5
000018  d104              BNE      |L3.36|
;;;139    		{
;;;140    			/* Reset the frame counter */
;;;141    			FrameCount = 0;
00001a  2000              MOVS     r0,#0
00001c  4611              MOV      r1,r2
00001e  6008              STR      r0,[r1,#0]  ; FrameCount
;;;142    			
;;;143    			/* Check the data to be sent through IN pipe */
;;;144    			EP1_IN_Callback();
000020  f7fffffe          BL       EP1_IN_Callback
                  |L3.36|
;;;145    			//Handle_USBAsynchXfer();
;;;146    		}
;;;147    	}  
;;;148    }
000024  bd10              POP      {r4,pc}
;;;149    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      bDeviceState
                  |L3.44|
                          DCD      FrameCount

                          AREA ||.data||, DATA, ALIGN=2

                  FrameCount
                          DCD      0x00000000
