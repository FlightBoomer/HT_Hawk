; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -I..\..\User\Algorithm\ekf2 -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usart.crf ..\..\User\Driver\UART\usart.c]
                          THUMB

                          AREA ||i.DMA_USART1_Configuration||, CODE, READONLY, ALIGN=2

                  DMA_USART1_Configuration PROC
;;;60     
;;;61     void DMA_USART1_Configuration(void)
000000  b500              PUSH     {lr}
;;;62     {
000002  b08b              SUB      sp,sp,#0x2c
;;;63     	DMA_InitTypeDef DMA_InitStructure;
;;;64     
;;;65     	DMA_DeInit(DMA1_Channel4);
000004  4814              LDR      r0,|L1.88|
000006  f7fffffe          BL       DMA_DeInit
;;;66     	DMA_InitStructure.DMA_PeripheralBaseAddr = USART1_DR_Base;//已经宏定义了，内存地址&串口数据寄存器地址
00000a  4814              LDR      r0,|L1.92|
00000c  9000              STR      r0,[sp,#0]
;;;67     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)sendbuf;  //这个地址无所谓，后边发送的时候会重新赋值。
00000e  4814              LDR      r0,|L1.96|
000010  9001              STR      r0,[sp,#4]
;;;68     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
000012  2010              MOVS     r0,#0x10
000014  9002              STR      r0,[sp,#8]
;;;69     	DMA_InitStructure.DMA_BufferSize = datanum; //传输数据大小
000016  4813              LDR      r0,|L1.100|
000018  7800              LDRB     r0,[r0,#0]  ; datanum
00001a  9003              STR      r0,[sp,#0xc]
;;;70     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00001c  2000              MOVS     r0,#0
00001e  9004              STR      r0,[sp,#0x10]
;;;71     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000020  2080              MOVS     r0,#0x80
000022  9005              STR      r0,[sp,#0x14]
;;;72     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
000024  2000              MOVS     r0,#0
000026  9006              STR      r0,[sp,#0x18]
;;;73     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000028  9007              STR      r0,[sp,#0x1c]
;;;74     	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;//DMA模式一次传输，不循环;DMA_Mode_Circular//
00002a  9008              STR      r0,[sp,#0x20]
;;;75     	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;//优先级中
00002c  f44f5080          MOV      r0,#0x1000
000030  9009              STR      r0,[sp,#0x24]
;;;76     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000032  2000              MOVS     r0,#0
000034  900a              STR      r0,[sp,#0x28]
;;;77     	DMA_Init(DMA1_Channel4, &DMA_InitStructure);
000036  4669              MOV      r1,sp
000038  4807              LDR      r0,|L1.88|
00003a  f7fffffe          BL       DMA_Init
;;;78     
;;;79     	/* Enable DMA1 Channel4Transfer Complete interrupt */  
;;;80     	DMA_ITConfig(DMA1_Channel4,DMA_IT_TC, ENABLE);   
00003e  2201              MOVS     r2,#1
000040  2102              MOVS     r1,#2
000042  4805              LDR      r0,|L1.88|
000044  f7fffffe          BL       DMA_ITConfig
;;;81       //USART_DMACmd(USART1,USART_DMAReq_Rx,ENABLE);    //不需要DMA方式接收                                                                //串口接收器DMA  
;;;82       //采用DMA方式发送  
;;;83     	USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);  //使能串口1的DMA发送 
000048  2201              MOVS     r2,#1
00004a  2180              MOVS     r1,#0x80
00004c  4803              LDR      r0,|L1.92|
00004e  1f00              SUBS     r0,r0,#4
000050  f7fffffe          BL       USART_DMACmd
;;;84     }
000054  b00b              ADD      sp,sp,#0x2c
000056  bd00              POP      {pc}
;;;85     
                          ENDP

                  |L1.88|
                          DCD      0x40020044
                  |L1.92|
                          DCD      0x40013804
                  |L1.96|
                          DCD      sendbuf
                  |L1.100|
                          DCD      datanum

                          AREA ||i.UART1_Put_Char||, CODE, READONLY, ALIGN=2

                  UART1_Put_Char PROC
;;;93     *******************************************************************************/
;;;94     uint8_t UART1_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;95     {
000002  4604              MOV      r4,r0
;;;96     	//将要发送的字节写到UART1的发送缓冲区
;;;97     	USART_SendData(USART1, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4806              LDR      r0,|L2.32|
000008  f7fffffe          BL       USART_SendData
;;;98     	//等待发送完成
;;;99       	while (!(USART1->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L2.14|
00000e  4804              LDR      r0,|L2.32|
000010  8800              LDRH     r0,[r0,#0]
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L2.14|
;;;100    	return DataToSend;
00001a  4620              MOV      r0,r4
;;;101    }
00001c  bd10              POP      {r4,pc}
;;;102    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x40013800

                          AREA ||i.UART2_Put_Char||, CODE, READONLY, ALIGN=2

                  UART2_Put_Char PROC
;;;281    *******************************************************************************/
;;;282    uint8_t UART2_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284    	//将要发送的字节写到UART1的发送缓冲区
;;;285    	USART_SendData(USART2, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4806              LDR      r0,|L3.32|
000008  f7fffffe          BL       USART_SendData
;;;286    	//等待发送完成
;;;287      	while (!(USART2->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L3.14|
00000e  4804              LDR      r0,|L3.32|
000010  8800              LDRH     r0,[r0,#0]
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L3.14|
;;;288    	return DataToSend;
00001a  4620              MOV      r0,r4
;;;289    }
00001c  bd10              POP      {r4,pc}
;;;290    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40004400

                          AREA ||i.USART1_Config||, CODE, READONLY, ALIGN=2

                  USART1_Config PROC
;;;18     
;;;19     void USART1_Config(void)
000000  b500              PUSH     {lr}
;;;20     {
000002  b085              SUB      sp,sp,#0x14
;;;21     	GPIO_InitTypeDef GPIO_InitStructure;
;;;22     	USART_InitTypeDef USART_InitStructure;
;;;23     	
;;;24     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_AFIO |RCC_APB2Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440005          MOV      r0,#0x4005
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;25     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);//开启DMA1的时钟
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;26     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0010          STRH     r0,[sp,#0x10]
;;;27     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d0013          STRB     r0,[sp,#0x13]
;;;28     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d0012          STRB     r0,[sp,#0x12]
;;;29     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002a  a904              ADD      r1,sp,#0x10
00002c  4817              LDR      r0,|L4.140|
00002e  f7fffffe          BL       GPIO_Init
;;;30     	
;;;31     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  f44f6080          MOV      r0,#0x400
000036  f8ad0010          STRH     r0,[sp,#0x10]
;;;32     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0013          STRB     r0,[sp,#0x13]
;;;33     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000040  a904              ADD      r1,sp,#0x10
000042  4812              LDR      r0,|L4.140|
000044  f7fffffe          BL       GPIO_Init
;;;34     	
;;;35     	// 设置波特率
;;;36     	USART_InitStructure.USART_BaudRate = HAWK_USART1_BAUD;   
000048  f44f30e1          MOV      r0,#0x1c200
00004c  9000              STR      r0,[sp,#0]
;;;37     	
;;;38     	// 设置数据位为8位
;;;39       USART_InitStructure.USART_WordLength = USART_WordLength_8b; 
00004e  2000              MOVS     r0,#0
000050  f8ad0004          STRH     r0,[sp,#4]
;;;40     
;;;41       // 设置停止位为1位	
;;;42       USART_InitStructure.USART_StopBits = USART_StopBits_1;  
000054  f8ad0006          STRH     r0,[sp,#6]
;;;43     
;;;44       // 无奇偶校验
;;;45       USART_InitStructure.USART_Parity = USART_Parity_No;  
000058  f8ad0008          STRH     r0,[sp,#8]
;;;46     
;;;47       // 没有硬件流控
;;;48       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; 
00005c  f8ad000c          STRH     r0,[sp,#0xc]
;;;49     	
;;;50     	// 发送与接收
;;;51       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;     
000060  200c              MOVS     r0,#0xc
000062  f8ad000a          STRH     r0,[sp,#0xa]
;;;52         
;;;53     	/*完成串口COM1的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;54     	USART_Init(USART1, &USART_InitStructure);
000066  4669              MOV      r1,sp
000068  4809              LDR      r0,|L4.144|
00006a  f7fffffe          BL       USART_Init
;;;55     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);////只使用接收中断，不使用发送中断
00006e  2201              MOVS     r2,#1
000070  f2405125          MOV      r1,#0x525
000074  4806              LDR      r0,|L4.144|
000076  f7fffffe          BL       USART_ITConfig
;;;56     	USART_Cmd(USART1, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  4804              LDR      r0,|L4.144|
00007e  f7fffffe          BL       USART_Cmd
;;;57     	DMA_USART1_Configuration();//用DMA有误码待解决
000082  f7fffffe          BL       DMA_USART1_Configuration
;;;58     }
000086  b005              ADD      sp,sp,#0x14
000088  bd00              POP      {pc}
;;;59     
                          ENDP

00008a  0000              DCW      0x0000
                  |L4.140|
                          DCD      0x40010800
                  |L4.144|
                          DCD      0x40013800

                          AREA ||i.USART1_printf||, CODE, READONLY, ALIGN=1

                  USART1_printf PROC
;;;174     */
;;;175    void USART1_printf(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;176    {
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
;;;177    	const char *s;
;;;178      int d;   
;;;179      char buf[16];
;;;180    
;;;181      va_list ap;
;;;182      va_start(ap, Data);
000008  a80c              ADD      r0,sp,#0x30
00000a  9001              STR      r0,[sp,#4]
;;;183    
;;;184    	while ( *Data != 0)     // 判断是否到达字符串结束符
00000c  e073              B        |L5.246|
                  |L5.14|
;;;185    	{				                          
;;;186    		if ( *Data == 0x5c )  //'\'
00000e  980b              LDR      r0,[sp,#0x2c]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d11c              BNE      |L5.80|
;;;187    		{									  
;;;188    			switch ( *++Data )
000016  980b              LDR      r0,[sp,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  900b              STR      r0,[sp,#0x2c]
00001c  7800              LDRB     r0,[r0,#0]
00001e  286e              CMP      r0,#0x6e
000020  d009              BEQ      |L5.54|
000022  2872              CMP      r0,#0x72
000024  d10f              BNE      |L5.70|
;;;189    			{
;;;190    				case 'r':							          //回车符
;;;191    					USART_SendData(USARTx, 0x0d);
000026  210d              MOVS     r1,#0xd
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       USART_SendData
;;;192    					Data ++;
00002e  980b              LDR      r0,[sp,#0x2c]
000030  1c40              ADDS     r0,r0,#1
000032  900b              STR      r0,[sp,#0x2c]
;;;193    					break;
000034  e00b              B        |L5.78|
                  |L5.54|
;;;194    
;;;195    				case 'n':							          //换行符
;;;196    					USART_SendData(USARTx, 0x0a);	
000036  210a              MOVS     r1,#0xa
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       USART_SendData
;;;197    					Data ++;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  1c40              ADDS     r0,r0,#1
000042  900b              STR      r0,[sp,#0x2c]
;;;198    					break;
000044  e003              B        |L5.78|
                  |L5.70|
;;;199    				
;;;200    				default:
;;;201    					Data ++;
000046  980b              LDR      r0,[sp,#0x2c]
000048  1c40              ADDS     r0,r0,#1
00004a  900b              STR      r0,[sp,#0x2c]
;;;202    				    break;
00004c  bf00              NOP      
                  |L5.78|
00004e  e04b              B        |L5.232|
                  |L5.80|
;;;203    			}			 
;;;204    		}
;;;205    		else if ( *Data == '%')
000050  980b              LDR      r0,[sp,#0x2c]
000052  7800              LDRB     r0,[r0,#0]
000054  2825              CMP      r0,#0x25
000056  d140              BNE      |L5.218|
;;;206    		{									  //
;;;207    			switch ( *++Data )
000058  980b              LDR      r0,[sp,#0x2c]
00005a  1c40              ADDS     r0,r0,#1
00005c  900b              STR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2864              CMP      r0,#0x64
000062  d018              BEQ      |L5.150|
000064  2873              CMP      r0,#0x73
000066  d133              BNE      |L5.208|
;;;208    			{				
;;;209    				case 's':										  //字符串
;;;210    					s = va_arg(ap, const char *);
000068  9801              LDR      r0,[sp,#4]
00006a  c810              LDM      r0!,{r4}
00006c  9001              STR      r0,[sp,#4]
;;;211              for ( ; *s; s++) 
00006e  e00b              B        |L5.136|
                  |L5.112|
;;;212    					{
;;;213    						USART_SendData(USARTx,*s);
000070  7821              LDRB     r1,[r4,#0]
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       USART_SendData
;;;214    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
000078  bf00              NOP      
                  |L5.122|
00007a  2140              MOVS     r1,#0x40
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L5.122|
000086  1c64              ADDS     r4,r4,#1              ;211
                  |L5.136|
000088  7820              LDRB     r0,[r4,#0]            ;211
00008a  2800              CMP      r0,#0                 ;211
00008c  d1f0              BNE      |L5.112|
;;;215              }
;;;216    					Data++;
00008e  980b              LDR      r0,[sp,#0x2c]
000090  1c40              ADDS     r0,r0,#1
000092  900b              STR      r0,[sp,#0x2c]
;;;217              break;
000094  e020              B        |L5.216|
                  |L5.150|
;;;218    
;;;219            case 'd':										//十进制
;;;220              d = va_arg(ap, int);
000096  9801              LDR      r0,[sp,#4]
000098  c820              LDM      r0!,{r5}
00009a  9001              STR      r0,[sp,#4]
;;;221              itoa(d, buf, 10);
00009c  220a              MOVS     r2,#0xa
00009e  a902              ADD      r1,sp,#8
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       itoa
;;;222              for (s = buf; *s; s++) 
0000a6  ac02              ADD      r4,sp,#8
0000a8  e00b              B        |L5.194|
                  |L5.170|
;;;223    					{
;;;224    						USART_SendData(USARTx,*s);
0000aa  7821              LDRB     r1,[r4,#0]
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       USART_SendData
;;;225    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000b2  bf00              NOP      
                  |L5.180|
0000b4  2140              MOVS     r1,#0x40
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       USART_GetFlagStatus
0000bc  2800              CMP      r0,#0
0000be  d0f9              BEQ      |L5.180|
0000c0  1c64              ADDS     r4,r4,#1              ;222
                  |L5.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;222
0000c4  2800              CMP      r0,#0                 ;222
0000c6  d1f0              BNE      |L5.170|
;;;226              }
;;;227    					Data++;
0000c8  980b              LDR      r0,[sp,#0x2c]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  900b              STR      r0,[sp,#0x2c]
;;;228              break;
0000ce  e003              B        |L5.216|
                  |L5.208|
;;;229    				 default:
;;;230    						Data++;
0000d0  980b              LDR      r0,[sp,#0x2c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900b              STR      r0,[sp,#0x2c]
;;;231    				    break;
0000d6  bf00              NOP      
                  |L5.216|
0000d8  e006              B        |L5.232|
                  |L5.218|
;;;232    			}		 
;;;233    		} /* end of else if */
;;;234    		else USART_SendData(USARTx, *Data++);
0000da  980b              LDR      r0,[sp,#0x2c]
0000dc  f8101b01          LDRB     r1,[r0],#1
0000e0  900b              STR      r0,[sp,#0x2c]
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       USART_SendData
                  |L5.232|
;;;235    		while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000e8  bf00              NOP      
                  |L5.234|
0000ea  2140              MOVS     r1,#0x40
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       USART_GetFlagStatus
0000f2  2800              CMP      r0,#0
0000f4  d0f9              BEQ      |L5.234|
                  |L5.246|
0000f6  980b              LDR      r0,[sp,#0x2c]         ;184
0000f8  7800              LDRB     r0,[r0,#0]            ;184
0000fa  2800              CMP      r0,#0                 ;184
0000fc  d187              BNE      |L5.14|
;;;236    	}
;;;237    }
0000fe  b006              ADD      sp,sp,#0x18
000100  bc70              POP      {r4-r6}
000102  f85dfb14          LDR      pc,[sp],#0x14
;;;238    
                          ENDP


                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;113     */
;;;114    static char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;115    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;116        int     i, d;
;;;117        int     flag = 0;
000008  2700              MOVS     r7,#0
;;;118        char    *ptr = string;
00000a  4629              MOV      r1,r5
;;;119    
;;;120        /* This implementation only works for decimal numbers. */
;;;121        if (radix != 10)
00000c  2e0a              CMP      r6,#0xa
00000e  d003              BEQ      |L6.24|
;;;122        {
;;;123            *ptr = 0;
000010  2000              MOVS     r0,#0
000012  7008              STRB     r0,[r1,#0]
;;;124            return string;
000014  4628              MOV      r0,r5
                  |L6.22|
;;;125        }
;;;126    
;;;127        if (!value)
;;;128        {
;;;129            *ptr++ = 0x30;
;;;130            *ptr = 0;
;;;131            return string;
;;;132        }
;;;133    
;;;134        /* if this is a negative value insert the minus sign. */
;;;135        if (value < 0)
;;;136        {
;;;137            *ptr++ = '-';
;;;138    
;;;139            /* Make the value positive. */
;;;140            value *= -1;
;;;141        }
;;;142    
;;;143        for (i = 10000; i > 0; i /= 10)
;;;144        {
;;;145            d = value / i;
;;;146    
;;;147            if (d || flag)
;;;148            {
;;;149                *ptr++ = (char)(d + 0x30);
;;;150                value -= (d * i);
;;;151                flag = 1;
;;;152            }
;;;153        }
;;;154    
;;;155        /* Null terminate the string. */
;;;156        *ptr = 0;
;;;157    
;;;158        return string;
;;;159    
;;;160    } /* NCL_Itoa */
000016  bdf0              POP      {r4-r7,pc}
                  |L6.24|
000018  b933              CBNZ     r3,|L6.40|
00001a  2030              MOVS     r0,#0x30              ;129
00001c  f8010b01          STRB     r0,[r1],#1            ;129
000020  2000              MOVS     r0,#0                 ;130
000022  7008              STRB     r0,[r1,#0]            ;130
000024  4628              MOV      r0,r5                 ;131
000026  e7f6              B        |L6.22|
                  |L6.40|
000028  2b00              CMP      r3,#0                 ;135
00002a  da03              BGE      |L6.52|
00002c  202d              MOVS     r0,#0x2d              ;137
00002e  f8010b01          STRB     r0,[r1],#1            ;137
000032  425b              RSBS     r3,r3,#0              ;140
                  |L6.52|
000034  f2427210          MOV      r2,#0x2710            ;143
000038  e00d              B        |L6.86|
                  |L6.58|
00003a  fb93f4f2          SDIV     r4,r3,r2              ;145
00003e  b904              CBNZ     r4,|L6.66|
000040  b137              CBZ      r7,|L6.80|
                  |L6.66|
000042  f1040030          ADD      r0,r4,#0x30           ;149
000046  f8010b01          STRB     r0,[r1],#1            ;149
00004a  fb043312          MLS      r3,r4,r2,r3           ;150
00004e  2701              MOVS     r7,#1                 ;151
                  |L6.80|
000050  200a              MOVS     r0,#0xa               ;143
000052  fb92f2f0          SDIV     r2,r2,r0              ;143
                  |L6.86|
000056  2a00              CMP      r2,#0                 ;143
000058  dcef              BGT      |L6.58|
00005a  2000              MOVS     r0,#0                 ;156
00005c  7008              STRB     r0,[r1,#0]            ;156
00005e  4628              MOV      r0,r5                 ;158
000060  e7d9              B        |L6.22|
;;;161    
                          ENDP


                          AREA ||i.usart2_config||, CODE, READONLY, ALIGN=2

                  usart2_config PROC
;;;239    /**************【目前暂未使用串口2】*******************/
;;;240    void usart2_config(void)
000000  b500              PUSH     {lr}
;;;241    {
000002  b085              SUB      sp,sp,#0x14
;;;242    	GPIO_InitTypeDef GPIO_InitStructure;
;;;243    	USART_InitTypeDef USART_InitStructure;
;;;244    	
;;;245    		/* config USART2 clock */
;;;246    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
000004  2101              MOVS     r1,#1
000006  2020              MOVS     r0,#0x20
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;247    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;248      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);  //使能AFIO功能的时钟
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;249      GPIO_PinRemapConfig(GPIO_Remap_USART2 ,ENABLE);  //进行重映射
00001c  2101              MOVS     r1,#1
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       GPIO_PinRemapConfig
;;;250    	
;;;251    	
;;;252      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000024  2020              MOVS     r0,#0x20
000026  f8ad0010          STRH     r0,[sp,#0x10]
;;;253      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00002a  2018              MOVS     r0,#0x18
00002c  f88d0013          STRB     r0,[sp,#0x13]
;;;254      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0012          STRB     r0,[sp,#0x12]
;;;255      GPIO_Init(GPIOD, &GPIO_InitStructure);
000036  a904              ADD      r1,sp,#0x10
000038  4815              LDR      r0,|L7.144|
00003a  f7fffffe          BL       GPIO_Init
;;;256    	    
;;;257      /* Configure USART2 Rx (PD.09) as input floating */
;;;258      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00003e  2040              MOVS     r0,#0x40
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;259      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000044  2004              MOVS     r0,#4
000046  f88d0013          STRB     r0,[sp,#0x13]
;;;260      GPIO_Init(GPIOD, &GPIO_InitStructure);
00004a  a904              ADD      r1,sp,#0x10
00004c  4810              LDR      r0,|L7.144|
00004e  f7fffffe          BL       GPIO_Init
;;;261    	
;;;262    	USART_InitStructure.USART_BaudRate = 9600;                 /*设置波特率为115200*/
000052  f44f5016          MOV      r0,#0x2580
000056  9000              STR      r0,[sp,#0]
;;;263    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;  /*设置数据位为8位*/
000058  2000              MOVS     r0,#0
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;264    	USART_InitStructure.USART_StopBits = USART_StopBits_1;       /*设置停止位为1位*/
00005e  f8ad0006          STRH     r0,[sp,#6]
;;;265    	USART_InitStructure.USART_Parity = USART_Parity_No;          /*无奇偶校验*/    
000062  f8ad0008          STRH     r0,[sp,#8]
;;;266    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; /*没有硬件流控*/
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;267    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;      /*发送与接收*/
00006a  200c              MOVS     r0,#0xc
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;268    	/*完成串口COM3的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;269    	
;;;270    	USART_Init(USART2, &USART_InitStructure);
000070  4669              MOV      r1,sp
000072  4808              LDR      r0,|L7.148|
000074  f7fffffe          BL       USART_Init
;;;271    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000078  2201              MOVS     r2,#1
00007a  f2405125          MOV      r1,#0x525
00007e  4805              LDR      r0,|L7.148|
000080  f7fffffe          BL       USART_ITConfig
;;;272    	USART_Cmd(USART2, ENABLE);
000084  2101              MOVS     r1,#1
000086  4803              LDR      r0,|L7.148|
000088  f7fffffe          BL       USART_Cmd
;;;273    }
00008c  b005              ADD      sp,sp,#0x14
00008e  bd00              POP      {pc}
;;;274    
                          ENDP

                  |L7.144|
                          DCD      0x40011400
                  |L7.148|
                          DCD      0x40004400

                          AREA ||.data||, DATA, ALIGN=0

                  sendbuf
000000  01020304          DCB      0x01,0x02,0x03,0x04
000004  05                DCB      0x05
                  datanum
000005  05                DCB      0x05
