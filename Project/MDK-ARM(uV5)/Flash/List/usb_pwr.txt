; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_pwr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usb_pwr.crf ..\..\User\usb_virture_com\usb_pwr.c]
                          THUMB

                          AREA ||i.usb_PowerOff||, CODE, READONLY, ALIGN=2

                  usb_PowerOff PROC
;;;81     */
;;;82     RESULT usb_PowerOff()
000000  b510              PUSH     {r4,lr}
;;;83     {
;;;84     	/* 禁止所有的中断，并且强制USB复位 */
;;;85     	_SetCNTR(CNTR_FRES);
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L1.28|
000006  6008              STR      r0,[r1,#0]
;;;86     	
;;;87     	/* 清零中断状态寄存器 */
;;;88     	_SetISTR(0);
000008  2000              MOVS     r0,#0
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;89     	
;;;90     	/* 断开USB D+线的上拉电阻，此时USB集线器会认为设备已拔除 */
;;;91     	usb_CableConfig(DISABLE);
00000e  f7fffffe          BL       usb_CableConfig
;;;92     	
;;;93     	/* 关闭USB设备电源 */
;;;94     	_SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  4901              LDR      r1,|L1.28|
000016  6008              STR      r0,[r1,#0]
;;;95     	
;;;96     	/* 可以在此处添加语句，复位一些变量 */
;;;97     	
;;;98     	return USB_SUCCESS;
000018  2000              MOVS     r0,#0
;;;99     }
00001a  bd10              POP      {r4,pc}
;;;100    
                          ENDP

                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.usb_PowerOn||, CODE, READONLY, ALIGN=2

                  usb_PowerOn PROC
;;;42     */
;;;43     RESULT usb_PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     	uint16_t wRegVal;
;;;46     	
;;;47     	/* 这个函数实质上将USB连接控制线设置为高电平，然后USB集线器就可以检测到设备了 */
;;;48     	usb_CableConfig(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       usb_CableConfig
;;;49     	
;;;50     	/* 当集线器报告设备连接状态，并收到主机指令后，会复位USB总线，这需要一定的时间.
;;;51     	这段时间内设备应该准备好处理复位指令） */
;;;52     	
;;;53     	/* 使能USB模块的电源。因为上电复位时，CNTR寄存器的断电控制为PDWN位是1，模块是断电的  */
;;;54     	wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;55     	_SetCNTR(wRegVal);	/* 这是一个宏，wRegVal赋值给CNTR寄存器，此时所有的中断被屏蔽 */
00000a  480b              LDR      r0,|L2.56|
00000c  6004              STR      r4,[r0,#0]
;;;56     	
;;;57     	wInterrupt_Mask = 0;		/* 全局变量在 wInterrupt_Maskusb_init.c 中定义。表示中断屏蔽配置 */
00000e  2000              MOVS     r0,#0
000010  490a              LDR      r1,|L2.60|
000012  8008              STRH     r0,[r1,#0]
;;;58     	_SetCNTR(wInterrupt_Mask);	/* wInterrupt_Mask = 0， 屏蔽所有的USB中断 */
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000018  4907              LDR      r1,|L2.56|
00001a  6008              STR      r0,[r1,#0]
;;;59     	
;;;60     	_SetISTR(0);			/* 清除可能存在的USB中断请求标志 */
00001c  2000              MOVS     r0,#0
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;61     	
;;;62     	/* 
;;;63     		使能需要的USB中断
;;;64     		CNTR_RESETM 表示使能复位中断，此时集线器多半还未开始复位端口，或者或稍等片刻就会复位USB设备
;;;65     		CNTR_SUSPM 表示使能USB设备挂起中断
;;;66     		CNTR_SUSPM 表示使能USB设备唤醒中断
;;;67     	*/
;;;68     	wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000022  f44f50e0          MOV      r0,#0x1c00
000026  4905              LDR      r1,|L2.60|
000028  8008              STRH     r0,[r1,#0]
;;;69     	_SetCNTR(wInterrupt_Mask);
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00002e  4902              LDR      r1,|L2.56|
000030  6008              STR      r0,[r1,#0]
;;;70     	
;;;71     	return USB_SUCCESS;	/* 固定返回 USB_SUCCESS */
000032  2000              MOVS     r0,#0
;;;72     }
000034  bd10              POP      {r4,pc}
;;;73     
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40005c40
                  |L2.60|
                          DCD      wInterrupt_Mask

                          AREA ||i.usb_Resume||, CODE, READONLY, ALIGN=2

                  usb_Resume PROC
;;;175    */
;;;176    void usb_Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;177    {
000002  4605              MOV      r5,r0
;;;178    	uint16_t wCNTR;
;;;179    	
;;;180    	if (eResumeSetVal != RESUME_ESOF)
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;181    	{
;;;182    		ResumeS.eState = eResumeSetVal;
000008  4827              LDR      r0,|L3.168|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;183    	}
;;;184    	
;;;185    	switch (ResumeS.eState)
00000c  4826              LDR      r0,|L3.168|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d241              BCS      |L3.152|
000014  e8dff000          TBB      [pc,r0]
000018  040a1016          DCB      0x04,0x0a,0x10,0x16
00001c  212e4142          DCB      0x21,0x2e,0x41,0x42
;;;186    	{
;;;187    		case RESUME_EXTERNAL:
;;;188    			usb_ResumeInit();
000020  f7fffffe          BL       usb_ResumeInit
;;;189    			ResumeS.eState = RESUME_OFF;
000024  2006              MOVS     r0,#6
000026  4920              LDR      r1,|L3.168|
000028  7008              STRB     r0,[r1,#0]
;;;190    			break;
00002a  e03b              B        |L3.164|
;;;191    			
;;;192    		case RESUME_INTERNAL:
;;;193    			usb_ResumeInit();
00002c  f7fffffe          BL       usb_ResumeInit
;;;194    			ResumeS.eState = RESUME_START;
000030  2004              MOVS     r0,#4
000032  491d              LDR      r1,|L3.168|
000034  7008              STRB     r0,[r1,#0]
;;;195    			break;
000036  e035              B        |L3.164|
;;;196    			
;;;197    		case RESUME_LATER:
;;;198    			ResumeS.bESOFcnt = 2;
000038  2002              MOVS     r0,#2
00003a  491b              LDR      r1,|L3.168|
00003c  7048              STRB     r0,[r1,#1]
;;;199    			ResumeS.eState = RESUME_WAIT;
00003e  2003              MOVS     r0,#3
000040  7008              STRB     r0,[r1,#0]
;;;200    			break;
000042  e02f              B        |L3.164|
;;;201    			
;;;202    		case RESUME_WAIT:
;;;203    			ResumeS.bESOFcnt--;
000044  4818              LDR      r0,|L3.168|
000046  7840              LDRB     r0,[r0,#1]  ; ResumeS
000048  1e40              SUBS     r0,r0,#1
00004a  4917              LDR      r1,|L3.168|
00004c  7048              STRB     r0,[r1,#1]
;;;204    			if (ResumeS.bESOFcnt == 0)
00004e  4608              MOV      r0,r1
000050  7840              LDRB     r0,[r0,#1]  ; ResumeS
000052  b908              CBNZ     r0,|L3.88|
;;;205    			ResumeS.eState = RESUME_START;
000054  2004              MOVS     r0,#4
000056  7008              STRB     r0,[r1,#0]
                  |L3.88|
;;;206    			break;
000058  e024              B        |L3.164|
;;;207    			
;;;208    		case RESUME_START:
;;;209    			wCNTR = _GetCNTR();
00005a  4814              LDR      r0,|L3.172|
00005c  6800              LDR      r0,[r0,#0]
00005e  b284              UXTH     r4,r0
;;;210    			wCNTR |= CNTR_RESUME;
000060  f0440410          ORR      r4,r4,#0x10
;;;211    			_SetCNTR(wCNTR);
000064  4811              LDR      r0,|L3.172|
000066  6004              STR      r4,[r0,#0]
;;;212    			ResumeS.eState = RESUME_ON;
000068  2005              MOVS     r0,#5
00006a  490f              LDR      r1,|L3.168|
00006c  7008              STRB     r0,[r1,#0]
;;;213    			ResumeS.bESOFcnt = 10;
00006e  200a              MOVS     r0,#0xa
000070  7048              STRB     r0,[r1,#1]
;;;214    			break;
000072  e017              B        |L3.164|
;;;215    			
;;;216    		case RESUME_ON:
;;;217    			ResumeS.bESOFcnt--;
000074  480c              LDR      r0,|L3.168|
000076  7840              LDRB     r0,[r0,#1]  ; ResumeS
000078  1e40              SUBS     r0,r0,#1
00007a  490b              LDR      r1,|L3.168|
00007c  7048              STRB     r0,[r1,#1]
;;;218    			if (ResumeS.bESOFcnt == 0)
00007e  4608              MOV      r0,r1
000080  7840              LDRB     r0,[r0,#1]  ; ResumeS
000082  b940              CBNZ     r0,|L3.150|
;;;219    			{
;;;220    				wCNTR = _GetCNTR();
000084  4809              LDR      r0,|L3.172|
000086  6800              LDR      r0,[r0,#0]
000088  b284              UXTH     r4,r0
;;;221    				wCNTR &= (~CNTR_RESUME);
00008a  f0240410          BIC      r4,r4,#0x10
;;;222    				_SetCNTR(wCNTR);
00008e  4807              LDR      r0,|L3.172|
000090  6004              STR      r4,[r0,#0]
;;;223    				ResumeS.eState = RESUME_OFF;
000092  2006              MOVS     r0,#6
000094  7008              STRB     r0,[r1,#0]
                  |L3.150|
;;;224    			}
;;;225    			break;
000096  e005              B        |L3.164|
                  |L3.152|
;;;226    			
;;;227    		case RESUME_OFF:
000098  bf00              NOP      
;;;228    		case RESUME_ESOF:
00009a  bf00              NOP      
;;;229    		default:
;;;230    			ResumeS.eState = RESUME_OFF;
00009c  2006              MOVS     r0,#6
00009e  4902              LDR      r1,|L3.168|
0000a0  7008              STRB     r0,[r1,#0]
;;;231    			break;
0000a2  bf00              NOP      
                  |L3.164|
0000a4  bf00              NOP                            ;190
;;;232    	}
;;;233    }
0000a6  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L3.168|
                          DCD      ResumeS
                  |L3.172|
                          DCD      0x40005c40

                          AREA ||i.usb_ResumeInit||, CODE, READONLY, ALIGN=2

                  usb_ResumeInit PROC
;;;144    */
;;;145    void usb_ResumeInit(void)
000000  b510              PUSH     {r4,lr}
;;;146    {
;;;147    	uint16_t wCNTR;
;;;148    	
;;;149    	/* ------------------ 仅用于USB总线供电的设备 ---------------------- */
;;;150    	
;;;151    	/* 此处可添加恢复时钟的代码 */
;;;152    	
;;;153    	/* CNTR_LPMODE = 0， 退出低功耗模式 */
;;;154    	wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;155    	wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;156    	_SetCNTR(wCNTR);
00000c  4804              LDR      r0,|L4.32|
00000e  6004              STR      r4,[r0,#0]
;;;157    	
;;;158    	/* 退出低功耗模式，恢复系统时钟。设置必要的全局变量 */
;;;159    	usb_LeaveLowPowerMode();
000010  f7fffffe          BL       usb_LeaveLowPowerMode
;;;160    	
;;;161    	/* 复位 FSUSP 位 */
;;;162    	_SetCNTR(IMR_MSK);	/* IMR_MSK宏在usb_conf.h中定义。*/
000014  f44f4006          MOV      r0,#0x8600
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]
;;;163    	/* #define IMR_MSK (CNTR_CTRM  | CNTR_SOFM  | CNTR_RESETM ) */
;;;164    	
;;;165    	/* 此处可添加挂起准备的反操作代码 */
;;;166    }
00001c  bd10              POP      {r4,pc}
;;;167    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40005c40

                          AREA ||i.usb_Suspend||, CODE, READONLY, ALIGN=2

                  usb_Suspend PROC
;;;108    */
;;;109    void usb_Suspend(void)
000000  b510              PUSH     {r4,lr}
;;;110    {
;;;111    	uint16_t wCNTR;
;;;112    	
;;;113    	/* 可以在此处添加USB挂起的准备工作 */
;;;114    	/* ... */
;;;115    	
;;;116    	/* 强制USB设备进入挂起状态 */
;;;117    	wCNTR = _GetCNTR();
000002  4808              LDR      r0,|L5.36|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;118    	wCNTR |= CNTR_FSUSP;
000008  f0440408          ORR      r4,r4,#8
;;;119    	_SetCNTR(wCNTR);
00000c  4805              LDR      r0,|L5.36|
00000e  6004              STR      r4,[r0,#0]
;;;120    
;;;121    	/* ------------------ 下面的部分仅用于USB总线供电的设备 ---------------------- */
;;;122    	
;;;123    	/* 强制进入低功耗模式 */
;;;124    	wCNTR = _GetCNTR();
000010  6800              LDR      r0,[r0,#0]
000012  b284              UXTH     r4,r0
;;;125    	wCNTR |= CNTR_LPMODE;
000014  f0440404          ORR      r4,r4,#4
;;;126    	_SetCNTR(wCNTR);
000018  4802              LDR      r0,|L5.36|
00001a  6004              STR      r4,[r0,#0]
;;;127    	
;;;128    	/* 为降低功耗，可以在此处切换CPU主时钟 */
;;;129    	
;;;130    	/* 
;;;131    		设置表示USB状态的全局变量，并且根据需要关闭一些中断和电源模式。 
;;;132    		这个函数多数由用户自己添加相关的代码。在 usb_hw.c 文件 
;;;133    	*/
;;;134    	usb_EnterLowPowerMode();	
00001c  f7fffffe          BL       usb_EnterLowPowerMode
;;;135    }
000020  bd10              POP      {r4,pc}
;;;136    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40005c40

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  01                DCB      0x01
                  ResumeS
000005  0000              DCB      0x00,0x00
