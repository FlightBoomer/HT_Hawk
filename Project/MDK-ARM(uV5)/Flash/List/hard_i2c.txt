; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\hard_i2c.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\hard_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\hard_i2c.crf ..\..\User\Driver\IIC\hard_i2c.c]
                          THUMB

                          AREA ||i.I2C1_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_ER_IRQHandler PROC
;;;44     
;;;45     void I2C1_ER_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47         i2c_er_handler();
000002  f7fffffe          BL       i2c_er_handler
;;;48     }
000006  bd10              POP      {r4,pc}
;;;49     
                          ENDP


                          AREA ||i.I2C1_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_EV_IRQHandler PROC
;;;49     
;;;50     void I2C1_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52         i2c_ev_handler();
000002  f7fffffe          BL       i2c_ev_handler
;;;53     }
000006  bd10              POP      {r4,pc}
;;;54     
                          ENDP


                          AREA ||i.I2C2_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_ER_IRQHandler PROC
;;;54     
;;;55     void I2C2_ER_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;56     {
;;;57         i2c_er_handler();
000002  f7fffffe          BL       i2c_er_handler
;;;58     }
000006  bd10              POP      {r4,pc}
;;;59     
                          ENDP


                          AREA ||i.I2C2_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_EV_IRQHandler PROC
;;;59     
;;;60     void I2C2_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62         i2c_ev_handler();
000002  f7fffffe          BL       i2c_ev_handler
;;;63     }
000006  bd10              POP      {r4,pc}
;;;64     
                          ENDP


                          AREA ||i.i2cGetErrorCounter||, CODE, READONLY, ALIGN=2

                  i2cGetErrorCounter PROC
;;;345    
;;;346    uint16_t i2cGetErrorCounter(void)
000000  4801              LDR      r0,|L5.8|
;;;347    {
;;;348        return i2cErrorCount;
000002  8800              LDRH     r0,[r0,#0]  ; i2cErrorCount
;;;349    }
000004  4770              BX       lr
;;;350    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      i2cErrorCount

                          AREA ||i.i2cHandleHardwareFailure||, CODE, READONLY, ALIGN=2

                  i2cHandleHardwareFailure PROC
;;;78     
;;;79     static bool i2cHandleHardwareFailure(void)
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81         i2cErrorCount++;
000002  4805              LDR      r0,|L6.24|
000004  8800              LDRH     r0,[r0,#0]  ; i2cErrorCount
000006  1c40              ADDS     r0,r0,#1
000008  4903              LDR      r1,|L6.24|
00000a  8008              STRH     r0,[r1,#0]
;;;82         // reinit peripheral + clock out garbage
;;;83         i2cInit(I2Cx_index);
00000c  4803              LDR      r0,|L6.28|
00000e  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
000010  f7fffffe          BL       i2cInit
;;;84         return FALSE;
000014  2000              MOVS     r0,#0
;;;85     }
000016  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L6.24|
                          DCD      i2cErrorCount
                  |L6.28|
                          DCD      I2Cx_index

                          AREA ||i.i2cInit||, CODE, READONLY, ALIGN=2

                  i2cInit PROC
;;;303    
;;;304    void i2cInit(I2CDevice index)
000000  b510              PUSH     {r4,lr}
;;;305    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;306        NVIC_InitTypeDef nvic;
;;;307        I2C_InitTypeDef i2c;
;;;308    
;;;309        if (index > I2CDEV_MAX)
000006  2c01              CMP      r4,#1
000008  dd00              BLE      |L7.12|
;;;310            index = I2CDEV_MAX;
00000a  2401              MOVS     r4,#1
                  |L7.12|
;;;311    
;;;312        // Turn on peripheral clock, save device and index
;;;313        I2Cx = i2cHardwareMap[index].dev;
00000c  eb040084          ADD      r0,r4,r4,LSL #2
000010  492c              LDR      r1,|L7.196|
000012  f8510020          LDR      r0,[r1,r0,LSL #2]
000016  492c              LDR      r1,|L7.200|
000018  6008              STR      r0,[r1,#0]  ; I2Cx
;;;314        I2Cx_index = index;
00001a  482c              LDR      r0,|L7.204|
00001c  7004              STRB     r4,[r0,#0]
;;;315        RCC_APB1PeriphClockCmd(i2cHardwareMap[index].peripheral, ENABLE);
00001e  eb040184          ADD      r1,r4,r4,LSL #2
000022  4a28              LDR      r2,|L7.196|
000024  eb020181          ADD      r1,r2,r1,LSL #2
000028  6908              LDR      r0,[r1,#0x10]
00002a  2101              MOVS     r1,#1
00002c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;316    
;;;317        // clock out stuff to make sure slaves arent stuck
;;;318        // This will also configure GPIO as AF_OD at the end
;;;319        i2cUnstick();
000030  f7fffffe          BL       i2cUnstick
;;;320    
;;;321        // Init I2C peripheral
;;;322        I2C_DeInit(I2Cx);
000034  4824              LDR      r0,|L7.200|
000036  6800              LDR      r0,[r0,#0]  ; I2Cx
000038  f7fffffe          BL       I2C_DeInit
;;;323        I2C_StructInit(&i2c);
00003c  a801              ADD      r0,sp,#4
00003e  f7fffffe          BL       I2C_StructInit
;;;324    
;;;325        I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);               // Enable EVT and ERR interrupts - they are enabled by the first request
000042  2200              MOVS     r2,#0
000044  f44f7140          MOV      r1,#0x300
000048  481f              LDR      r0,|L7.200|
00004a  6800              LDR      r0,[r0,#0]  ; I2Cx
00004c  f7fffffe          BL       I2C_ITConfig
;;;326        i2c.I2C_Mode = I2C_Mode_I2C;
000050  2000              MOVS     r0,#0
000052  f8ad0008          STRH     r0,[sp,#8]
;;;327        i2c.I2C_DutyCycle = I2C_DutyCycle_2;
000056  f64b70ff          MOV      r0,#0xbfff
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;328        i2c.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00005e  f44f4080          MOV      r0,#0x4000
000062  f8ad0010          STRH     r0,[sp,#0x10]
;;;329        i2c.I2C_ClockSpeed = 400000;
000066  481a              LDR      r0,|L7.208|
000068  9001              STR      r0,[sp,#4]
;;;330        I2C_Cmd(I2Cx, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4816              LDR      r0,|L7.200|
00006e  6800              LDR      r0,[r0,#0]  ; I2Cx
000070  f7fffffe          BL       I2C_Cmd
;;;331        I2C_Init(I2Cx, &i2c);
000074  a901              ADD      r1,sp,#4
000076  4814              LDR      r0,|L7.200|
000078  6800              LDR      r0,[r0,#0]  ; I2Cx
00007a  f7fffffe          BL       I2C_Init
;;;332    
;;;333        // I2C ER Interrupt
;;;334        nvic.NVIC_IRQChannel = i2cHardwareMap[index].er_irq;
00007e  eb040084          ADD      r0,r4,r4,LSL #2
000082  4910              LDR      r1,|L7.196|
000084  eb010080          ADD      r0,r1,r0,LSL #2
000088  7b40              LDRB     r0,[r0,#0xd]
00008a  f88d0014          STRB     r0,[sp,#0x14]
;;;335        nvic.NVIC_IRQChannelPreemptionPriority = 0;
00008e  2000              MOVS     r0,#0
000090  f88d0015          STRB     r0,[sp,#0x15]
;;;336        nvic.NVIC_IRQChannelSubPriority = 0;
000094  f88d0016          STRB     r0,[sp,#0x16]
;;;337        nvic.NVIC_IRQChannelCmd = ENABLE;
000098  2001              MOVS     r0,#1
00009a  f88d0017          STRB     r0,[sp,#0x17]
;;;338        NVIC_Init(&nvic);
00009e  a805              ADD      r0,sp,#0x14
0000a0  f7fffffe          BL       NVIC_Init
;;;339    
;;;340        // I2C EV Interrupt
;;;341        nvic.NVIC_IRQChannel = i2cHardwareMap[index].ev_irq;
0000a4  eb040084          ADD      r0,r4,r4,LSL #2
0000a8  4906              LDR      r1,|L7.196|
0000aa  eb010080          ADD      r0,r1,r0,LSL #2
0000ae  7b00              LDRB     r0,[r0,#0xc]
0000b0  f88d0014          STRB     r0,[sp,#0x14]
;;;342        nvic.NVIC_IRQChannelPreemptionPriority = 0;
0000b4  2000              MOVS     r0,#0
0000b6  f88d0015          STRB     r0,[sp,#0x15]
;;;343        NVIC_Init(&nvic);
0000ba  a805              ADD      r0,sp,#0x14
0000bc  f7fffffe          BL       NVIC_Init
;;;344    }
0000c0  b006              ADD      sp,sp,#0x18
0000c2  bd10              POP      {r4,pc}
;;;345    
                          ENDP

                  |L7.196|
                          DCD      i2cHardwareMap
                  |L7.200|
                          DCD      I2Cx
                  |L7.204|
                          DCD      I2Cx_index
                  |L7.208|
                          DCD      0x00061a80

                          AREA ||i.i2cRead||, CODE, READONLY, ALIGN=2

                  i2cRead PROC
;;;130    
;;;131    bool i2cRead(uint8_t addr_, uint8_t reg_, uint8_t len, uint8_t *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;132    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;133        uint32_t timeout = I2C_DEFAULT_TIMEOUT;
00000c  f2475430          MOV      r4,#0x7530
;;;134    
;;;135        addr = addr_ << 1;
000010  0670              LSLS     r0,r6,#25
000012  0e00              LSRS     r0,r0,#24
000014  4928              LDR      r1,|L8.184|
000016  7008              STRB     r0,[r1,#0]
;;;136        reg = reg_;
000018  4828              LDR      r0,|L8.188|
00001a  7007              STRB     r7,[r0,#0]
;;;137        writing = 0;
00001c  2000              MOVS     r0,#0
00001e  4928              LDR      r1,|L8.192|
000020  7008              STRB     r0,[r1,#0]
;;;138        reading = 1;
000022  2001              MOVS     r0,#1
000024  4927              LDR      r1,|L8.196|
000026  7008              STRB     r0,[r1,#0]
;;;139        read_p = buf;
000028  4827              LDR      r0,|L8.200|
00002a  6005              STR      r5,[r0,#0]  ; read_p
;;;140        write_p = buf;
00002c  4827              LDR      r0,|L8.204|
00002e  6005              STR      r5,[r0,#0]  ; write_p
;;;141        bytes = len;
000030  4827              LDR      r0,|L8.208|
000032  f8808000          STRB     r8,[r0,#0]
;;;142        busy = TRUE;
000036  2001              MOVS     r0,#1
000038  4926              LDR      r1,|L8.212|
00003a  7008              STRB     r0,[r1,#0]
;;;143        error = FALSE;
00003c  2000              MOVS     r0,#0
00003e  4926              LDR      r1,|L8.216|
000040  7008              STRB     r0,[r1,#0]
;;;144    
;;;145        if (!I2Cx)
000042  4826              LDR      r0,|L8.220|
000044  6800              LDR      r0,[r0,#0]  ; I2Cx
000046  b910              CBNZ     r0,|L8.78|
;;;146            return FALSE;
000048  2000              MOVS     r0,#0
                  |L8.74|
;;;147    
;;;148        if (!(I2Cx->CR2 & I2C_IT_EVT)) {                                    // if we are restarting the driver
;;;149            if (!(I2Cx->CR1 & 0x0100)) {                                    // ensure sending a start
;;;150                while (I2Cx->CR1 & 0x0200 && --timeout > 0) {
;;;151                    ;    // wait for any stop to finish sending
;;;152                }
;;;153                if (timeout == 0)
;;;154                    return i2cHandleHardwareFailure();
;;;155                I2C_GenerateSTART(I2Cx, ENABLE);                            // send the start for the new job
;;;156            }
;;;157            I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, ENABLE);            // allow the interrupts to fire off again
;;;158        }
;;;159    
;;;160        timeout = I2C_DEFAULT_TIMEOUT;
;;;161        while (busy && --timeout > 0) {
;;;162            ;
;;;163        }
;;;164        if (timeout == 0)
;;;165            return i2cHandleHardwareFailure();
;;;166    
;;;167        return TRUE;
;;;168    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.78|
00004e  4823              LDR      r0,|L8.220|
000050  6800              LDR      r0,[r0,#0]            ;148  ; I2Cx
000052  8880              LDRH     r0,[r0,#4]            ;148
000054  f4007000          AND      r0,r0,#0x200          ;148
000058  b9f8              CBNZ     r0,|L8.154|
00005a  4820              LDR      r0,|L8.220|
00005c  6800              LDR      r0,[r0,#0]            ;149  ; I2Cx
00005e  8800              LDRH     r0,[r0,#0]            ;149
000060  f4007080          AND      r0,r0,#0x100          ;149
000064  b990              CBNZ     r0,|L8.140|
000066  bf00              NOP                            ;150
                  |L8.104|
000068  481c              LDR      r0,|L8.220|
00006a  6800              LDR      r0,[r0,#0]            ;150  ; I2Cx
00006c  8800              LDRH     r0,[r0,#0]            ;150
00006e  f4007000          AND      r0,r0,#0x200          ;150
000072  b110              CBZ      r0,|L8.122|
000074  1e60              SUBS     r0,r4,#1              ;150
000076  0004              MOVS     r4,r0                 ;150
000078  d1f6              BNE      |L8.104|
                  |L8.122|
00007a  b914              CBNZ     r4,|L8.130|
00007c  f7fffffe          BL       i2cHandleHardwareFailure
000080  e7e3              B        |L8.74|
                  |L8.130|
000082  2101              MOVS     r1,#1                 ;155
000084  4815              LDR      r0,|L8.220|
000086  6800              LDR      r0,[r0,#0]            ;155  ; I2Cx
000088  f7fffffe          BL       I2C_GenerateSTART
                  |L8.140|
00008c  2201              MOVS     r2,#1                 ;157
00008e  f44f7140          MOV      r1,#0x300             ;157
000092  4812              LDR      r0,|L8.220|
000094  6800              LDR      r0,[r0,#0]            ;157  ; I2Cx
000096  f7fffffe          BL       I2C_ITConfig
                  |L8.154|
00009a  f2475430          MOV      r4,#0x7530            ;160
00009e  bf00              NOP                            ;161
                  |L8.160|
0000a0  480c              LDR      r0,|L8.212|
0000a2  7800              LDRB     r0,[r0,#0]            ;161  ; busy
0000a4  b110              CBZ      r0,|L8.172|
0000a6  1e60              SUBS     r0,r4,#1              ;161
0000a8  0004              MOVS     r4,r0                 ;161
0000aa  d1f9              BNE      |L8.160|
                  |L8.172|
0000ac  b914              CBNZ     r4,|L8.180|
0000ae  f7fffffe          BL       i2cHandleHardwareFailure
0000b2  e7ca              B        |L8.74|
                  |L8.180|
0000b4  2001              MOVS     r0,#1                 ;167
0000b6  e7c8              B        |L8.74|
;;;169    
                          ENDP

                  |L8.184|
                          DCD      addr
                  |L8.188|
                          DCD      ||reg||
                  |L8.192|
                          DCD      writing
                  |L8.196|
                          DCD      reading
                  |L8.200|
                          DCD      read_p
                  |L8.204|
                          DCD      write_p
                  |L8.208|
                          DCD      bytes
                  |L8.212|
                          DCD      busy
                  |L8.216|
                          DCD      error
                  |L8.220|
                          DCD      I2Cx

                          AREA ||i.i2cUnstick||, CODE, READONLY, ALIGN=2

                  i2cUnstick PROC
;;;350    
;;;351    static void i2cUnstick(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;352    {
;;;353        GPIO_TypeDef *gpio;
;;;354        GPIO_InitTypeDef GPIO_InitStructure;
;;;355        uint16_t scl, sda;
;;;356        int i;
;;;357        
;;;358    	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;359    	
;;;360        // prepare pins
;;;361        gpio = i2cHardwareMap[I2Cx_index].gpio;
00000a  4837              LDR      r0,|L9.232|
00000c  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00000e  eb000080          ADD      r0,r0,r0,LSL #2
000012  4936              LDR      r1,|L9.236|
000014  eb010080          ADD      r0,r1,r0,LSL #2
000018  6847              LDR      r7,[r0,#4]
;;;362        scl = i2cHardwareMap[I2Cx_index].scl;
00001a  4833              LDR      r0,|L9.232|
00001c  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  eb010080          ADD      r0,r1,r0,LSL #2
000026  8904              LDRH     r4,[r0,#8]
;;;363        sda = i2cHardwareMap[I2Cx_index].sda;
000028  482f              LDR      r0,|L9.232|
00002a  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00002c  eb000080          ADD      r0,r0,r0,LSL #2
000030  eb010080          ADD      r0,r1,r0,LSL #2
000034  8945              LDRH     r5,[r0,#0xa]
;;;364        
;;;365        GPIO_SetBits(gpio, scl | sda);
000036  ea440105          ORR      r1,r4,r5
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       GPIO_SetBits
;;;366    
;;;367        GPIO_InitStructure.GPIO_Pin = scl | sda;
000040  ea440005          ORR      r0,r4,r5
000044  f8ad0000          STRH     r0,[sp,#0]
;;;368        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000048  2002              MOVS     r0,#2
00004a  f88d0002          STRB     r0,[sp,#2]
;;;369        GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_OD;
00004e  2014              MOVS     r0,#0x14
000050  f88d0003          STRB     r0,[sp,#3]
;;;370        GPIO_Init(gpio, &GPIO_InitStructure);
000054  4669              MOV      r1,sp
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       GPIO_Init
;;;371    
;;;372        for (i = 0; i < 8; i++) {
00005c  2600              MOVS     r6,#0
00005e  e018              B        |L9.146|
                  |L9.96|
;;;373            // Wait for any clock stretching to finish
;;;374            while (!GPIO_ReadInputDataBit(gpio, scl))
000060  e002              B        |L9.104|
                  |L9.98|
;;;375                delay(10);
000062  200a              MOVS     r0,#0xa
000064  f7fffffe          BL       delay
                  |L9.104|
000068  4621              MOV      r1,r4                 ;374
00006a  4638              MOV      r0,r7                 ;374
00006c  f7fffffe          BL       GPIO_ReadInputDataBit
000070  2800              CMP      r0,#0                 ;374
000072  d0f6              BEQ      |L9.98|
;;;376    
;;;377            // Pull low
;;;378            GPIO_ResetBits(gpio, scl); // Set bus low
000074  4621              MOV      r1,r4
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       GPIO_ResetBits
;;;379            delay(10);
00007c  200a              MOVS     r0,#0xa
00007e  f7fffffe          BL       delay
;;;380            // Release high again
;;;381            GPIO_SetBits(gpio, scl); // Set bus high
000082  4621              MOV      r1,r4
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       GPIO_SetBits
;;;382            delay(10);
00008a  200a              MOVS     r0,#0xa
00008c  f7fffffe          BL       delay
000090  1c76              ADDS     r6,r6,#1              ;372
                  |L9.146|
000092  2e08              CMP      r6,#8                 ;372
000094  dbe4              BLT      |L9.96|
;;;383        }
;;;384    
;;;385        // Generate a start then stop condition
;;;386        // SCL  PB10
;;;387        // SDA  PB11
;;;388        GPIO_ResetBits(gpio, sda); // Set bus data low
000096  4629              MOV      r1,r5
000098  4638              MOV      r0,r7
00009a  f7fffffe          BL       GPIO_ResetBits
;;;389        delay(10);
00009e  200a              MOVS     r0,#0xa
0000a0  f7fffffe          BL       delay
;;;390        GPIO_ResetBits(gpio, scl); // Set bus scl low
0000a4  4621              MOV      r1,r4
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       GPIO_ResetBits
;;;391        delay(10);
0000ac  200a              MOVS     r0,#0xa
0000ae  f7fffffe          BL       delay
;;;392        GPIO_SetBits(gpio, scl); // Set bus scl high
0000b2  4621              MOV      r1,r4
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       GPIO_SetBits
;;;393        delay(10);
0000ba  200a              MOVS     r0,#0xa
0000bc  f7fffffe          BL       delay
;;;394        GPIO_SetBits(gpio, sda); // Set bus sda high
0000c0  4629              MOV      r1,r5
0000c2  4638              MOV      r0,r7
0000c4  f7fffffe          BL       GPIO_SetBits
;;;395    
;;;396        // Init pins
;;;397        GPIO_InitStructure.GPIO_Pin = scl | sda;
0000c8  ea440005          ORR      r0,r4,r5
0000cc  f8ad0000          STRH     r0,[sp,#0]
;;;398        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000d0  2002              MOVS     r0,#2
0000d2  f88d0002          STRB     r0,[sp,#2]
;;;399        GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_AF_OD;
0000d6  201c              MOVS     r0,#0x1c
0000d8  f88d0003          STRB     r0,[sp,#3]
;;;400        GPIO_Init(gpio, &GPIO_InitStructure);
0000dc  4669              MOV      r1,sp
0000de  4638              MOV      r0,r7
0000e0  f7fffffe          BL       GPIO_Init
;;;401    }
0000e4  bdf8              POP      {r3-r7,pc}
;;;402    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L9.232|
                          DCD      I2Cx_index
                  |L9.236|
                          DCD      i2cHardwareMap

                          AREA ||i.i2cWrite||, CODE, READONLY, ALIGN=1

                  i2cWrite PROC
;;;125    
;;;126    bool i2cWrite(uint8_t addr_, uint8_t reg_, uint8_t data)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;127    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;128        return i2cWriteBuffer(addr_, reg_, 1, &data);
000006  ab02              ADD      r3,sp,#8
000008  2201              MOVS     r2,#1
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       i2cWriteBuffer
;;;129    }
000012  bd3e              POP      {r1-r5,pc}
;;;130    
                          ENDP


                          AREA ||i.i2cWriteBuffer||, CODE, READONLY, ALIGN=2

                  i2cWriteBuffer PROC
;;;86     
;;;87     bool i2cWriteBuffer(uint8_t addr_, uint8_t reg_, uint8_t len_, uint8_t *data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;88     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;89         uint32_t timeout = I2C_DEFAULT_TIMEOUT;
00000c  f2475430          MOV      r4,#0x7530
;;;90     
;;;91         addr = addr_ << 1;
000010  0670              LSLS     r0,r6,#25
000012  0e00              LSRS     r0,r0,#24
000014  4928              LDR      r1,|L11.184|
000016  7008              STRB     r0,[r1,#0]
;;;92         reg = reg_;
000018  4828              LDR      r0,|L11.188|
00001a  7007              STRB     r7,[r0,#0]
;;;93         writing = 1;
00001c  2001              MOVS     r0,#1
00001e  4928              LDR      r1,|L11.192|
000020  7008              STRB     r0,[r1,#0]
;;;94         reading = 0;
000022  2000              MOVS     r0,#0
000024  4927              LDR      r1,|L11.196|
000026  7008              STRB     r0,[r1,#0]
;;;95         write_p = data;
000028  4827              LDR      r0,|L11.200|
00002a  6005              STR      r5,[r0,#0]  ; write_p
;;;96         read_p = data;
00002c  4827              LDR      r0,|L11.204|
00002e  6005              STR      r5,[r0,#0]  ; read_p
;;;97         bytes = len_;
000030  4827              LDR      r0,|L11.208|
000032  f8808000          STRB     r8,[r0,#0]
;;;98         busy = TRUE;
000036  2001              MOVS     r0,#1
000038  4926              LDR      r1,|L11.212|
00003a  7008              STRB     r0,[r1,#0]
;;;99         error = FALSE;
00003c  2000              MOVS     r0,#0
00003e  4926              LDR      r1,|L11.216|
000040  7008              STRB     r0,[r1,#0]
;;;100    
;;;101        if (!I2Cx)
000042  4826              LDR      r0,|L11.220|
000044  6800              LDR      r0,[r0,#0]  ; I2Cx
000046  b910              CBNZ     r0,|L11.78|
;;;102            return FALSE;
000048  2000              MOVS     r0,#0
                  |L11.74|
;;;103    
;;;104        if (!(I2Cx->CR2 & I2C_IT_EVT)) {                                    // if we are restarting the driver
;;;105            if (!(I2Cx->CR1 & 0x0100)) {                                    // ensure sending a start
;;;106                while (I2Cx->CR1 & 0x0200 && --timeout > 0) {
;;;107                    ;    // wait for any stop to finish sending
;;;108                }
;;;109                if (timeout == 0)
;;;110                    return i2cHandleHardwareFailure();
;;;111                I2C_GenerateSTART(I2Cx, ENABLE);                            // send the start for the new job
;;;112            }
;;;113            I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, ENABLE);            // allow the interrupts to fire off again
;;;114        }
;;;115    
;;;116        timeout = I2C_DEFAULT_TIMEOUT;
;;;117        while (busy && --timeout > 0) {
;;;118            ;
;;;119        }
;;;120        if (timeout == 0)
;;;121            return i2cHandleHardwareFailure();
;;;122    
;;;123        return TRUE;
;;;124    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L11.78|
00004e  4823              LDR      r0,|L11.220|
000050  6800              LDR      r0,[r0,#0]            ;104  ; I2Cx
000052  8880              LDRH     r0,[r0,#4]            ;104
000054  f4007000          AND      r0,r0,#0x200          ;104
000058  b9f8              CBNZ     r0,|L11.154|
00005a  4820              LDR      r0,|L11.220|
00005c  6800              LDR      r0,[r0,#0]            ;105  ; I2Cx
00005e  8800              LDRH     r0,[r0,#0]            ;105
000060  f4007080          AND      r0,r0,#0x100          ;105
000064  b990              CBNZ     r0,|L11.140|
000066  bf00              NOP                            ;106
                  |L11.104|
000068  481c              LDR      r0,|L11.220|
00006a  6800              LDR      r0,[r0,#0]            ;106  ; I2Cx
00006c  8800              LDRH     r0,[r0,#0]            ;106
00006e  f4007000          AND      r0,r0,#0x200          ;106
000072  b110              CBZ      r0,|L11.122|
000074  1e60              SUBS     r0,r4,#1              ;106
000076  0004              MOVS     r4,r0                 ;106
000078  d1f6              BNE      |L11.104|
                  |L11.122|
00007a  b914              CBNZ     r4,|L11.130|
00007c  f7fffffe          BL       i2cHandleHardwareFailure
000080  e7e3              B        |L11.74|
                  |L11.130|
000082  2101              MOVS     r1,#1                 ;111
000084  4815              LDR      r0,|L11.220|
000086  6800              LDR      r0,[r0,#0]            ;111  ; I2Cx
000088  f7fffffe          BL       I2C_GenerateSTART
                  |L11.140|
00008c  2201              MOVS     r2,#1                 ;113
00008e  f44f7140          MOV      r1,#0x300             ;113
000092  4812              LDR      r0,|L11.220|
000094  6800              LDR      r0,[r0,#0]            ;113  ; I2Cx
000096  f7fffffe          BL       I2C_ITConfig
                  |L11.154|
00009a  f2475430          MOV      r4,#0x7530            ;116
00009e  bf00              NOP                            ;117
                  |L11.160|
0000a0  480c              LDR      r0,|L11.212|
0000a2  7800              LDRB     r0,[r0,#0]            ;117  ; busy
0000a4  b110              CBZ      r0,|L11.172|
0000a6  1e60              SUBS     r0,r4,#1              ;117
0000a8  0004              MOVS     r4,r0                 ;117
0000aa  d1f9              BNE      |L11.160|
                  |L11.172|
0000ac  b914              CBNZ     r4,|L11.180|
0000ae  f7fffffe          BL       i2cHandleHardwareFailure
0000b2  e7ca              B        |L11.74|
                  |L11.180|
0000b4  2001              MOVS     r0,#1                 ;123
0000b6  e7c8              B        |L11.74|
;;;125    
                          ENDP

                  |L11.184|
                          DCD      addr
                  |L11.188|
                          DCD      ||reg||
                  |L11.192|
                          DCD      writing
                  |L11.196|
                          DCD      reading
                  |L11.200|
                          DCD      write_p
                  |L11.204|
                          DCD      read_p
                  |L11.208|
                          DCD      bytes
                  |L11.212|
                          DCD      busy
                  |L11.216|
                          DCD      error
                  |L11.220|
                          DCD      I2Cx

                          AREA ||i.i2c_er_handler||, CODE, READONLY, ALIGN=2

                  i2c_er_handler PROC
;;;169    
;;;170    static void i2c_er_handler(void)
000000  b508              PUSH     {r3,lr}
;;;171    {
;;;172        // Read the I2C1 status register
;;;173        volatile uint32_t SR1Register = I2Cx->SR1;
000002  482e              LDR      r0,|L12.188|
000004  6800              LDR      r0,[r0,#0]  ; I2Cx
000006  8a80              LDRH     r0,[r0,#0x14]
000008  9000              STR      r0,[sp,#0]
;;;174    
;;;175        if (SR1Register & 0x0F00)                                           // an error
00000a  9800              LDR      r0,[sp,#0]
00000c  f4006070          AND      r0,r0,#0xf00
000010  b110              CBZ      r0,|L12.24|
;;;176            error = TRUE;
000012  2001              MOVS     r0,#1
000014  492a              LDR      r1,|L12.192|
000016  7008              STRB     r0,[r1,#0]
                  |L12.24|
;;;177    
;;;178        // If AF, BERR or ARLO, abandon the current job and commence new if there are jobs
;;;179        if (SR1Register & 0x0700) {
000018  9800              LDR      r0,[sp,#0]
00001a  f40060e0          AND      r0,r0,#0x700
00001e  2800              CMP      r0,#0
000020  d03f              BEQ      |L12.162|
;;;180            (void)I2Cx->SR2;                                                // read second status register to clear ADDR if it is set (note that BTF will not be set after a NACK)
000022  4826              LDR      r0,|L12.188|
000024  6800              LDR      r0,[r0,#0]  ; I2Cx
000026  8b00              LDRH     r0,[r0,#0x18]
;;;181            I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                        // disable the RXNE/TXE interrupt - prevent the ISR tailchaining onto the ER (hopefully)
000028  2200              MOVS     r2,#0
00002a  f44f6180          MOV      r1,#0x400
00002e  4823              LDR      r0,|L12.188|
000030  6800              LDR      r0,[r0,#0]  ; I2Cx
000032  f7fffffe          BL       I2C_ITConfig
;;;182            if (!(SR1Register & 0x0200) && !(I2Cx->CR1 & 0x0200)) {         // if we dont have an ARLO error, ensure sending of a stop
000036  9800              LDR      r0,[sp,#0]
000038  f4007000          AND      r0,r0,#0x200
00003c  bb20              CBNZ     r0,|L12.136|
00003e  481f              LDR      r0,|L12.188|
000040  6800              LDR      r0,[r0,#0]  ; I2Cx
000042  8800              LDRH     r0,[r0,#0]
000044  f4007000          AND      r0,r0,#0x200
000048  b9f0              CBNZ     r0,|L12.136|
;;;183                if (I2Cx->CR1 & 0x0100) {                                   // We are currently trying to send a start, this is very bad as start, stop will hang the peripheral
00004a  481c              LDR      r0,|L12.188|
00004c  6800              LDR      r0,[r0,#0]  ; I2Cx
00004e  8800              LDRH     r0,[r0,#0]
000050  f4007080          AND      r0,r0,#0x100
000054  b1c8              CBZ      r0,|L12.138|
;;;184                    while (I2Cx->CR1 & 0x0100) {
000056  bf00              NOP      
                  |L12.88|
000058  4818              LDR      r0,|L12.188|
00005a  6800              LDR      r0,[r0,#0]  ; I2Cx
00005c  8800              LDRH     r0,[r0,#0]
00005e  f4007080          AND      r0,r0,#0x100
000062  2800              CMP      r0,#0
000064  d1f8              BNE      |L12.88|
;;;185                        ;    // wait for any start to finish sending
;;;186                    }
;;;187                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // send stop to finalise bus transaction
000066  2101              MOVS     r1,#1
000068  4814              LDR      r0,|L12.188|
00006a  6800              LDR      r0,[r0,#0]  ; I2Cx
00006c  f7fffffe          BL       I2C_GenerateSTOP
;;;188                    while (I2Cx->CR1 & 0x0200) {
000070  bf00              NOP      
                  |L12.114|
000072  4812              LDR      r0,|L12.188|
000074  6800              LDR      r0,[r0,#0]  ; I2Cx
000076  8800              LDRH     r0,[r0,#0]
000078  f4007000          AND      r0,r0,#0x200
00007c  2800              CMP      r0,#0
00007e  d1f8              BNE      |L12.114|
;;;189                        ;    // wait for stop to finish sending
;;;190                    }
;;;191                    i2cInit(I2Cx_index);                                    // reset and configure the hardware
000080  4810              LDR      r0,|L12.196|
000082  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
000084  f7fffffe          BL       i2cInit
                  |L12.136|
000088  e00b              B        |L12.162|
                  |L12.138|
;;;192                } else {
;;;193                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // stop to free up the bus
00008a  2101              MOVS     r1,#1
00008c  480b              LDR      r0,|L12.188|
00008e  6800              LDR      r0,[r0,#0]  ; I2Cx
000090  f7fffffe          BL       I2C_GenerateSTOP
;;;194                    I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);   // Disable EVT and ERR interrupts while bus inactive
000094  2200              MOVS     r2,#0
000096  f44f7140          MOV      r1,#0x300
00009a  4808              LDR      r0,|L12.188|
00009c  6800              LDR      r0,[r0,#0]  ; I2Cx
00009e  f7fffffe          BL       I2C_ITConfig
                  |L12.162|
;;;195                }
;;;196            }
;;;197        }
;;;198        I2Cx->SR1 &= ~0x0F00;                                               // reset all the error bits to clear the interrupt
0000a2  4806              LDR      r0,|L12.188|
0000a4  6800              LDR      r0,[r0,#0]  ; I2Cx
0000a6  8a80              LDRH     r0,[r0,#0x14]
0000a8  f4206070          BIC      r0,r0,#0xf00
0000ac  4903              LDR      r1,|L12.188|
0000ae  6809              LDR      r1,[r1,#0]  ; I2Cx
0000b0  8288              STRH     r0,[r1,#0x14]
;;;199        busy = FALSE;
0000b2  2000              MOVS     r0,#0
0000b4  4904              LDR      r1,|L12.200|
0000b6  7008              STRB     r0,[r1,#0]
;;;200    }
0000b8  bd08              POP      {r3,pc}
;;;201    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L12.188|
                          DCD      I2Cx
                  |L12.192|
                          DCD      error
                  |L12.196|
                          DCD      I2Cx_index
                  |L12.200|
                          DCD      busy

                          AREA ||i.i2c_ev_handler||, CODE, READONLY, ALIGN=2

                  i2c_ev_handler PROC
;;;201    
;;;202    void i2c_ev_handler(void)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        static uint8_t subaddress_sent, final_stop;                         // flag to indicate if subaddess sent, flag to indicate final bus condition
;;;205        static int8_t index;                                                // index is signed -1 == send the subaddress
;;;206        uint8_t SReg_1 = I2Cx->SR1;                                         // read the status register here
000002  48e8              LDR      r0,|L13.932|
000004  6800              LDR      r0,[r0,#0]  ; I2Cx
000006  8a80              LDRH     r0,[r0,#0x14]
000008  b2c4              UXTB     r4,r0
;;;207    
;;;208        if (SReg_1 & 0x0001) {                                              // we just sent a start - EV5 in ref manual
00000a  f0040001          AND      r0,r4,#1
00000e  2800              CMP      r0,#0
000010  d03f              BEQ      |L13.146|
;;;209            I2Cx->CR1 &= ~0x0800;                                           // reset the POS bit so ACK/NACK applied to the current byte
000012  48e4              LDR      r0,|L13.932|
000014  6800              LDR      r0,[r0,#0]  ; I2Cx
000016  8800              LDRH     r0,[r0,#0]
000018  f4206000          BIC      r0,r0,#0x800
00001c  49e1              LDR      r1,|L13.932|
00001e  6809              LDR      r1,[r1,#0]  ; I2Cx
000020  8008              STRH     r0,[r1,#0]
;;;210            I2C_AcknowledgeConfig(I2Cx, ENABLE);                            // make sure ACK is on
000022  2101              MOVS     r1,#1
000024  48df              LDR      r0,|L13.932|
000026  6800              LDR      r0,[r0,#0]  ; I2Cx
000028  f7fffffe          BL       I2C_AcknowledgeConfig
;;;211            index = 0;                                                      // reset the index
00002c  2000              MOVS     r0,#0
00002e  49de              LDR      r1,|L13.936|
000030  7008              STRB     r0,[r1,#0]
;;;212            if (reading && (subaddress_sent || 0xFF == reg)) {              // we have sent the subaddr
000032  48de              LDR      r0,|L13.940|
000034  7800              LDRB     r0,[r0,#0]  ; reading
000036  b1e8              CBZ      r0,|L13.116|
000038  48dd              LDR      r0,|L13.944|
00003a  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00003c  b918              CBNZ     r0,|L13.70|
00003e  48dd              LDR      r0,|L13.948|
000040  7800              LDRB     r0,[r0,#0]  ; reg
000042  28ff              CMP      r0,#0xff
000044  d116              BNE      |L13.116|
                  |L13.70|
;;;213                subaddress_sent = 1;                                        // make sure this is set in case of no subaddress, so following code runs correctly
000046  2001              MOVS     r0,#1
000048  49d9              LDR      r1,|L13.944|
00004a  7008              STRB     r0,[r1,#0]
;;;214                if (bytes == 2)
00004c  48da              LDR      r0,|L13.952|
00004e  7800              LDRB     r0,[r0,#0]  ; bytes
000050  2802              CMP      r0,#2
000052  d107              BNE      |L13.100|
;;;215                    I2Cx->CR1 |= 0x0800;                                    // set the POS bit so NACK applied to the final byte in the two byte read
000054  48d3              LDR      r0,|L13.932|
000056  6800              LDR      r0,[r0,#0]  ; I2Cx
000058  8800              LDRH     r0,[r0,#0]
00005a  f4406000          ORR      r0,r0,#0x800
00005e  49d1              LDR      r1,|L13.932|
000060  6809              LDR      r1,[r1,#0]  ; I2Cx
000062  8008              STRH     r0,[r1,#0]
                  |L13.100|
;;;216                I2C_Send7bitAddress(I2Cx, addr, I2C_Direction_Receiver);    // send the address and set hardware mode
000064  2201              MOVS     r2,#1
000066  48d5              LDR      r0,|L13.956|
000068  7801              LDRB     r1,[r0,#0]  ; addr
00006a  48ce              LDR      r0,|L13.932|
00006c  6800              LDR      r0,[r0,#0]  ; I2Cx
00006e  f7fffffe          BL       I2C_Send7bitAddress
                  |L13.114|
000072  e17d              B        |L13.880|
                  |L13.116|
;;;217            } else {                                                        // direction is Tx, or we havent sent the sub and rep start
;;;218                I2C_Send7bitAddress(I2Cx, addr, I2C_Direction_Transmitter); // send the address and set hardware mode
000074  2200              MOVS     r2,#0
000076  48d1              LDR      r0,|L13.956|
000078  7801              LDRB     r1,[r0,#0]  ; addr
00007a  48ca              LDR      r0,|L13.932|
00007c  6800              LDR      r0,[r0,#0]  ; I2Cx
00007e  f7fffffe          BL       I2C_Send7bitAddress
;;;219                if (reg != 0xFF)                                            // 0xFF as subaddress means it will be ignored, in Tx or Rx mode
000082  48cc              LDR      r0,|L13.948|
000084  7800              LDRB     r0,[r0,#0]  ; reg
000086  28ff              CMP      r0,#0xff
000088  d0f3              BEQ      |L13.114|
;;;220                    index = -1;                                             // send a subaddress
00008a  20ff              MOVS     r0,#0xff
00008c  49c6              LDR      r1,|L13.936|
00008e  7008              STRB     r0,[r1,#0]
000090  e16e              B        |L13.880|
                  |L13.146|
;;;221            }
;;;222        } else if (SReg_1 & 0x0002) {                                       // we just sent the address - EV6 in ref manual
000092  f0040002          AND      r0,r4,#2
000096  2800              CMP      r0,#0
000098  d059              BEQ      |L13.334|
;;;223            // Read SR1,2 to clear ADDR
;;;224            __DMB();                                                        // memory fence to control hardware
00009a  f3bf8f50          DMB      #0x0
;;;225            if (bytes == 1 && reading && subaddress_sent) {                 // we are receiving 1 byte - EV6_3
00009e  48c6              LDR      r0,|L13.952|
0000a0  7800              LDRB     r0,[r0,#0]  ; bytes
0000a2  2801              CMP      r0,#1
0000a4  d11e              BNE      |L13.228|
0000a6  48c1              LDR      r0,|L13.940|
0000a8  7800              LDRB     r0,[r0,#0]  ; reading
0000aa  b1d8              CBZ      r0,|L13.228|
0000ac  48c0              LDR      r0,|L13.944|
0000ae  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
0000b0  b1c0              CBZ      r0,|L13.228|
;;;226                I2C_AcknowledgeConfig(I2Cx, DISABLE);                       // turn off ACK
0000b2  2100              MOVS     r1,#0
0000b4  48bb              LDR      r0,|L13.932|
0000b6  6800              LDR      r0,[r0,#0]  ; I2Cx
0000b8  f7fffffe          BL       I2C_AcknowledgeConfig
;;;227                __DMB();
0000bc  f3bf8f50          DMB      #0x0
;;;228                (void)I2Cx->SR2;                                            // clear ADDR after ACK is turned off
0000c0  48b8              LDR      r0,|L13.932|
0000c2  6800              LDR      r0,[r0,#0]  ; I2Cx
0000c4  8b00              LDRH     r0,[r0,#0x18]
;;;229                I2C_GenerateSTOP(I2Cx, ENABLE);                             // program the stop
0000c6  2101              MOVS     r1,#1
0000c8  48b6              LDR      r0,|L13.932|
0000ca  6800              LDR      r0,[r0,#0]  ; I2Cx
0000cc  f7fffffe          BL       I2C_GenerateSTOP
;;;230                final_stop = 1;
0000d0  2001              MOVS     r0,#1
0000d2  49bb              LDR      r1,|L13.960|
0000d4  7008              STRB     r0,[r1,#0]
;;;231                I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);                     // allow us to have an EV7
0000d6  2201              MOVS     r2,#1
0000d8  0281              LSLS     r1,r0,#10
0000da  48b2              LDR      r0,|L13.932|
0000dc  6800              LDR      r0,[r0,#0]  ; I2Cx
0000de  f7fffffe          BL       I2C_ITConfig
0000e2  e145              B        |L13.880|
                  |L13.228|
;;;232            } else {                                                        // EV6 and EV6_1
;;;233                (void)I2Cx->SR2;                                            // clear the ADDR here
0000e4  48af              LDR      r0,|L13.932|
0000e6  6800              LDR      r0,[r0,#0]  ; I2Cx
0000e8  8b00              LDRH     r0,[r0,#0x18]
;;;234                __DMB();
0000ea  f3bf8f50          DMB      #0x0
;;;235                if (bytes == 2 && reading && subaddress_sent) {             // rx 2 bytes - EV6_1
0000ee  48b2              LDR      r0,|L13.952|
0000f0  7800              LDRB     r0,[r0,#0]  ; bytes
0000f2  2802              CMP      r0,#2
0000f4  d112              BNE      |L13.284|
0000f6  48ad              LDR      r0,|L13.940|
0000f8  7800              LDRB     r0,[r0,#0]  ; reading
0000fa  b178              CBZ      r0,|L13.284|
0000fc  48ac              LDR      r0,|L13.944|
0000fe  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000100  b160              CBZ      r0,|L13.284|
;;;236                    I2C_AcknowledgeConfig(I2Cx, DISABLE);                   // turn off ACK
000102  2100              MOVS     r1,#0
000104  48a7              LDR      r0,|L13.932|
000106  6800              LDR      r0,[r0,#0]  ; I2Cx
000108  f7fffffe          BL       I2C_AcknowledgeConfig
;;;237                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to fill
00010c  2200              MOVS     r2,#0
00010e  f44f6180          MOV      r1,#0x400
000112  48a4              LDR      r0,|L13.932|
000114  6800              LDR      r0,[r0,#0]  ; I2Cx
000116  f7fffffe          BL       I2C_ITConfig
00011a  e129              B        |L13.880|
                  |L13.284|
;;;238                } else if (bytes == 3 && reading && subaddress_sent)        // rx 3 bytes
00011c  48a6              LDR      r0,|L13.952|
00011e  7800              LDRB     r0,[r0,#0]  ; bytes
000120  2803              CMP      r0,#3
000122  d10d              BNE      |L13.320|
000124  48a1              LDR      r0,|L13.940|
000126  7800              LDRB     r0,[r0,#0]  ; reading
000128  b150              CBZ      r0,|L13.320|
00012a  48a1              LDR      r0,|L13.944|
00012c  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00012e  b138              CBZ      r0,|L13.320|
;;;239                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // make sure RXNE disabled so we get a BTF in two bytes time
000130  2200              MOVS     r2,#0
000132  f44f6180          MOV      r1,#0x400
000136  489b              LDR      r0,|L13.932|
000138  6800              LDR      r0,[r0,#0]  ; I2Cx
00013a  f7fffffe          BL       I2C_ITConfig
00013e  e117              B        |L13.880|
                  |L13.320|
;;;240                else                                                        // receiving greater than three bytes, sending subaddress, or transmitting
;;;241                    I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);
000140  2201              MOVS     r2,#1
000142  0291              LSLS     r1,r2,#10
000144  4897              LDR      r0,|L13.932|
000146  6800              LDR      r0,[r0,#0]  ; I2Cx
000148  f7fffffe          BL       I2C_ITConfig
00014c  e110              B        |L13.880|
                  |L13.334|
;;;242            }
;;;243        } else if (SReg_1 & 0x004) {                                        // Byte transfer finished - EV7_2, EV7_3 or EV8_2
00014e  f0040004          AND      r0,r4,#4
000152  2800              CMP      r0,#0
000154  d072              BEQ      |L13.572|
;;;244            final_stop = 1;
000156  2001              MOVS     r0,#1
000158  4999              LDR      r1,|L13.960|
00015a  7008              STRB     r0,[r1,#0]
;;;245            if (reading && subaddress_sent) {                               // EV7_2, EV7_3
00015c  4893              LDR      r0,|L13.940|
00015e  7800              LDRB     r0,[r0,#0]  ; reading
000160  2800              CMP      r0,#0
000162  d06d              BEQ      |L13.576|
000164  4892              LDR      r0,|L13.944|
000166  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000168  2800              CMP      r0,#0
00016a  d069              BEQ      |L13.576|
;;;246                if (bytes > 2) {                                            // EV7_2
00016c  4892              LDR      r0,|L13.952|
00016e  7800              LDRB     r0,[r0,#0]  ; bytes
000170  2802              CMP      r0,#2
000172  dd31              BLE      |L13.472|
;;;247                    I2C_AcknowledgeConfig(I2Cx, DISABLE);                   // turn off ACK
000174  2100              MOVS     r1,#0
000176  488b              LDR      r0,|L13.932|
000178  6800              LDR      r0,[r0,#0]  ; I2Cx
00017a  f7fffffe          BL       I2C_AcknowledgeConfig
;;;248                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N-2
00017e  4889              LDR      r0,|L13.932|
000180  6800              LDR      r0,[r0,#0]  ; I2Cx
000182  8a00              LDRH     r0,[r0,#0x10]
000184  b2c1              UXTB     r1,r0
000186  4888              LDR      r0,|L13.936|
000188  f9902000          LDRSB    r2,[r0,#0]  ; index
00018c  7800              LDRB     r0,[r0,#0]  ; index
00018e  1c40              ADDS     r0,r0,#1
000190  b240              SXTB     r0,r0
000192  4b85              LDR      r3,|L13.936|
000194  7018              STRB     r0,[r3,#0]
000196  488b              LDR      r0,|L13.964|
000198  6800              LDR      r0,[r0,#0]  ; read_p
00019a  5481              STRB     r1,[r0,r2]
;;;249                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // program the Stop
00019c  2101              MOVS     r1,#1
00019e  4881              LDR      r0,|L13.932|
0001a0  6800              LDR      r0,[r0,#0]  ; I2Cx
0001a2  f7fffffe          BL       I2C_GenerateSTOP
;;;250                    final_stop = 1;                                         // required to fix hardware
0001a6  2001              MOVS     r0,#1
0001a8  4985              LDR      r1,|L13.960|
0001aa  7008              STRB     r0,[r1,#0]
;;;251                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N - 1
0001ac  487d              LDR      r0,|L13.932|
0001ae  6800              LDR      r0,[r0,#0]  ; I2Cx
0001b0  8a00              LDRH     r0,[r0,#0x10]
0001b2  b2c1              UXTB     r1,r0
0001b4  487c              LDR      r0,|L13.936|
0001b6  f9902000          LDRSB    r2,[r0,#0]  ; index
0001ba  7800              LDRB     r0,[r0,#0]  ; index
0001bc  1c40              ADDS     r0,r0,#1
0001be  b240              SXTB     r0,r0
0001c0  4b79              LDR      r3,|L13.936|
0001c2  7018              STRB     r0,[r3,#0]
0001c4  487f              LDR      r0,|L13.964|
0001c6  6800              LDR      r0,[r0,#0]  ; read_p
0001c8  5481              STRB     r1,[r0,r2]
;;;252                    I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);                 // enable TXE to allow the final EV7
0001ca  2201              MOVS     r2,#1
0001cc  0291              LSLS     r1,r2,#10
0001ce  4875              LDR      r0,|L13.932|
0001d0  6800              LDR      r0,[r0,#0]  ; I2Cx
0001d2  f7fffffe          BL       I2C_ITConfig
0001d6  e056              B        |L13.646|
                  |L13.472|
;;;253                } else {                                                    // EV7_3
;;;254                    if (final_stop)
0001d8  4879              LDR      r0,|L13.960|
0001da  7800              LDRB     r0,[r0,#0]  ; final_stop
0001dc  b128              CBZ      r0,|L13.490|
;;;255                        I2C_GenerateSTOP(I2Cx, ENABLE);                     // program the Stop
0001de  2101              MOVS     r1,#1
0001e0  4870              LDR      r0,|L13.932|
0001e2  6800              LDR      r0,[r0,#0]  ; I2Cx
0001e4  f7fffffe          BL       I2C_GenerateSTOP
0001e8  e004              B        |L13.500|
                  |L13.490|
;;;256                    else
;;;257                        I2C_GenerateSTART(I2Cx, ENABLE);                    // program a rep start
0001ea  2101              MOVS     r1,#1
0001ec  486d              LDR      r0,|L13.932|
0001ee  6800              LDR      r0,[r0,#0]  ; I2Cx
0001f0  f7fffffe          BL       I2C_GenerateSTART
                  |L13.500|
;;;258                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N - 1
0001f4  486b              LDR      r0,|L13.932|
0001f6  6800              LDR      r0,[r0,#0]  ; I2Cx
0001f8  8a00              LDRH     r0,[r0,#0x10]
0001fa  b2c1              UXTB     r1,r0
0001fc  486a              LDR      r0,|L13.936|
0001fe  f9902000          LDRSB    r2,[r0,#0]  ; index
000202  7800              LDRB     r0,[r0,#0]  ; index
000204  1c40              ADDS     r0,r0,#1
000206  b240              SXTB     r0,r0
000208  4b67              LDR      r3,|L13.936|
00020a  7018              STRB     r0,[r3,#0]
00020c  486d              LDR      r0,|L13.964|
00020e  6800              LDR      r0,[r0,#0]  ; read_p
000210  5481              STRB     r1,[r0,r2]
;;;259                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N
000212  4864              LDR      r0,|L13.932|
000214  6800              LDR      r0,[r0,#0]  ; I2Cx
000216  8a00              LDRH     r0,[r0,#0x10]
000218  b2c1              UXTB     r1,r0
00021a  4618              MOV      r0,r3
00021c  f9902000          LDRSB    r2,[r0,#0]  ; index
000220  7800              LDRB     r0,[r0,#0]  ; index
000222  1c40              ADDS     r0,r0,#1
000224  b240              SXTB     r0,r0
000226  7018              STRB     r0,[r3,#0]
000228  4866              LDR      r0,|L13.964|
00022a  6800              LDR      r0,[r0,#0]  ; read_p
00022c  5481              STRB     r1,[r0,r2]
;;;260                    index++;                                                // to show job completed
00022e  4618              MOV      r0,r3
000230  7800              LDRB     r0,[r0,#0]  ; index
000232  1c40              ADDS     r0,r0,#1
000234  b240              SXTB     r0,r0
000236  4619              MOV      r1,r3
000238  7008              STRB     r0,[r1,#0]
00023a  e024              B        |L13.646|
                  |L13.572|
00023c  e02c              B        |L13.664|
00023e  e7ff              B        |L13.576|
                  |L13.576|
;;;261                }
;;;262            } else {                                                        // EV8_2, which may be due to a subaddress sent or a write completion
;;;263                if (subaddress_sent || (writing)) {
000240  485b              LDR      r0,|L13.944|
000242  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000244  b910              CBNZ     r0,|L13.588|
000246  4860              LDR      r0,|L13.968|
000248  7800              LDRB     r0,[r0,#0]  ; writing
00024a  b1a0              CBZ      r0,|L13.630|
                  |L13.588|
;;;264                    if (final_stop)
00024c  485c              LDR      r0,|L13.960|
00024e  7800              LDRB     r0,[r0,#0]  ; final_stop
000250  b128              CBZ      r0,|L13.606|
;;;265                        I2C_GenerateSTOP(I2Cx, ENABLE);                     // program the Stop
000252  2101              MOVS     r1,#1
000254  4853              LDR      r0,|L13.932|
000256  6800              LDR      r0,[r0,#0]  ; I2Cx
000258  f7fffffe          BL       I2C_GenerateSTOP
00025c  e004              B        |L13.616|
                  |L13.606|
;;;266                    else
;;;267                        I2C_GenerateSTART(I2Cx, ENABLE);                    // program a rep start
00025e  2101              MOVS     r1,#1
000260  4850              LDR      r0,|L13.932|
000262  6800              LDR      r0,[r0,#0]  ; I2Cx
000264  f7fffffe          BL       I2C_GenerateSTART
                  |L13.616|
;;;268                    index++;                                                // to show that the job is complete
000268  484f              LDR      r0,|L13.936|
00026a  7800              LDRB     r0,[r0,#0]  ; index
00026c  1c40              ADDS     r0,r0,#1
00026e  b240              SXTB     r0,r0
000270  494d              LDR      r1,|L13.936|
000272  7008              STRB     r0,[r1,#0]
000274  e007              B        |L13.646|
                  |L13.630|
;;;269                } else {                                                    // We need to send a subaddress
;;;270                    I2C_GenerateSTART(I2Cx, ENABLE);                        // program the repeated Start
000276  2101              MOVS     r1,#1
000278  484a              LDR      r0,|L13.932|
00027a  6800              LDR      r0,[r0,#0]  ; I2Cx
00027c  f7fffffe          BL       I2C_GenerateSTART
;;;271                    subaddress_sent = 1;                                    // this is set back to zero upon completion of the current task
000280  2001              MOVS     r0,#1
000282  494b              LDR      r1,|L13.944|
000284  7008              STRB     r0,[r1,#0]
                  |L13.646|
;;;272                }
;;;273            }
;;;274            // we must wait for the start to clear, otherwise we get constant BTF
;;;275            while (I2Cx->CR1 & 0x0100) {
000286  bf00              NOP      
                  |L13.648|
000288  4846              LDR      r0,|L13.932|
00028a  6800              LDR      r0,[r0,#0]  ; I2Cx
00028c  8800              LDRH     r0,[r0,#0]
00028e  f4007080          AND      r0,r0,#0x100
000292  2800              CMP      r0,#0
000294  d1f8              BNE      |L13.648|
000296  e06b              B        |L13.880|
                  |L13.664|
;;;276                ;
;;;277            }
;;;278        } else if (SReg_1 & 0x0040) {                                       // Byte received - EV7
000298  f0040040          AND      r0,r4,#0x40
00029c  b358              CBZ      r0,|L13.758|
;;;279            read_p[index++] = (uint8_t)I2Cx->DR;
00029e  4841              LDR      r0,|L13.932|
0002a0  6800              LDR      r0,[r0,#0]  ; I2Cx
0002a2  8a00              LDRH     r0,[r0,#0x10]
0002a4  b2c1              UXTB     r1,r0
0002a6  4840              LDR      r0,|L13.936|
0002a8  f9902000          LDRSB    r2,[r0,#0]  ; index
0002ac  7800              LDRB     r0,[r0,#0]  ; index
0002ae  1c40              ADDS     r0,r0,#1
0002b0  b240              SXTB     r0,r0
0002b2  4b3d              LDR      r3,|L13.936|
0002b4  7018              STRB     r0,[r3,#0]
0002b6  4843              LDR      r0,|L13.964|
0002b8  6800              LDR      r0,[r0,#0]  ; read_p
0002ba  5481              STRB     r1,[r0,r2]
;;;280            if (bytes == (index + 3))
0002bc  483e              LDR      r0,|L13.952|
0002be  7801              LDRB     r1,[r0,#0]  ; bytes
0002c0  4618              MOV      r0,r3
0002c2  f9900000          LDRSB    r0,[r0,#0]  ; index
0002c6  1cc0              ADDS     r0,r0,#3
0002c8  4281              CMP      r1,r0
0002ca  d106              BNE      |L13.730|
;;;281                I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                    // disable TXE to allow the buffer to flush so we can get an EV7_2
0002cc  2200              MOVS     r2,#0
0002ce  f44f6180          MOV      r1,#0x400
0002d2  4834              LDR      r0,|L13.932|
0002d4  6800              LDR      r0,[r0,#0]  ; I2Cx
0002d6  f7fffffe          BL       I2C_ITConfig
                  |L13.730|
;;;282            if (bytes == index)                                             // We have completed a final EV7
0002da  4837              LDR      r0,|L13.952|
0002dc  7800              LDRB     r0,[r0,#0]  ; bytes
0002de  4932              LDR      r1,|L13.936|
0002e0  f9911000          LDRSB    r1,[r1,#0]  ; index
0002e4  4288              CMP      r0,r1
0002e6  d143              BNE      |L13.880|
;;;283                index++;                                                    // to show job is complete
0002e8  482f              LDR      r0,|L13.936|
0002ea  7800              LDRB     r0,[r0,#0]  ; index
0002ec  1c40              ADDS     r0,r0,#1
0002ee  b240              SXTB     r0,r0
0002f0  492d              LDR      r1,|L13.936|
0002f2  7008              STRB     r0,[r1,#0]
0002f4  e03c              B        |L13.880|
                  |L13.758|
;;;284        } else if (SReg_1 & 0x0080) {                                       // Byte transmitted EV8 / EV8_1
0002f6  f0040080          AND      r0,r4,#0x80
0002fa  b300              CBZ      r0,|L13.830|
;;;285            if (index != -1) {                                              // we dont have a subaddress to send
0002fc  482a              LDR      r0,|L13.936|
0002fe  f9900000          LDRSB    r0,[r0,#0]  ; index
000302  1c40              ADDS     r0,r0,#1
000304  b1e0              CBZ      r0,|L13.832|
;;;286                I2Cx->DR = write_p[index++];
000306  4828              LDR      r0,|L13.936|
000308  f9901000          LDRSB    r1,[r0,#0]  ; index
00030c  7800              LDRB     r0,[r0,#0]  ; index
00030e  1c40              ADDS     r0,r0,#1
000310  b240              SXTB     r0,r0
000312  4a25              LDR      r2,|L13.936|
000314  7010              STRB     r0,[r2,#0]
000316  482d              LDR      r0,|L13.972|
000318  6800              LDR      r0,[r0,#0]  ; write_p
00031a  5c40              LDRB     r0,[r0,r1]
00031c  4921              LDR      r1,|L13.932|
00031e  6809              LDR      r1,[r1,#0]  ; I2Cx
000320  8208              STRH     r0,[r1,#0x10]
;;;287                if (bytes == index)                                         // we have sent all the data
000322  4825              LDR      r0,|L13.952|
000324  7800              LDRB     r0,[r0,#0]  ; bytes
000326  4611              MOV      r1,r2
000328  f9911000          LDRSB    r1,[r1,#0]  ; index
00032c  4288              CMP      r0,r1
00032e  d11f              BNE      |L13.880|
;;;288                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to flush
000330  2200              MOVS     r2,#0
000332  f44f6180          MOV      r1,#0x400
000336  481b              LDR      r0,|L13.932|
000338  6800              LDR      r0,[r0,#0]  ; I2Cx
00033a  f7fffffe          BL       I2C_ITConfig
                  |L13.830|
00033e  e017              B        |L13.880|
                  |L13.832|
;;;289            } else {
;;;290                index++;
000340  4819              LDR      r0,|L13.936|
000342  7800              LDRB     r0,[r0,#0]  ; index
000344  1c40              ADDS     r0,r0,#1
000346  b240              SXTB     r0,r0
000348  4917              LDR      r1,|L13.936|
00034a  7008              STRB     r0,[r1,#0]
;;;291                I2Cx->DR = reg;                                             // send the subaddress
00034c  4819              LDR      r0,|L13.948|
00034e  7800              LDRB     r0,[r0,#0]  ; reg
000350  4914              LDR      r1,|L13.932|
000352  6809              LDR      r1,[r1,#0]  ; I2Cx
000354  8208              STRH     r0,[r1,#0x10]
;;;292                if (reading || !bytes)                                      // if receiving or sending 0 bytes, flush now
000356  4815              LDR      r0,|L13.940|
000358  7800              LDRB     r0,[r0,#0]  ; reading
00035a  b910              CBNZ     r0,|L13.866|
00035c  4816              LDR      r0,|L13.952|
00035e  7800              LDRB     r0,[r0,#0]  ; bytes
000360  b930              CBNZ     r0,|L13.880|
                  |L13.866|
;;;293                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to flush
000362  2200              MOVS     r2,#0
000364  f44f6180          MOV      r1,#0x400
000368  480e              LDR      r0,|L13.932|
00036a  6800              LDR      r0,[r0,#0]  ; I2Cx
00036c  f7fffffe          BL       I2C_ITConfig
                  |L13.880|
;;;294            }
;;;295        }
;;;296        if (index == bytes + 1) {                                           // we have completed the current job
000370  480d              LDR      r0,|L13.936|
000372  f9901000          LDRSB    r1,[r0,#0]  ; index
000376  4810              LDR      r0,|L13.952|
000378  7800              LDRB     r0,[r0,#0]  ; bytes
00037a  1c40              ADDS     r0,r0,#1
00037c  4281              CMP      r1,r0
00037e  d10f              BNE      |L13.928|
;;;297            subaddress_sent = 0;                                            // reset this here
000380  2000              MOVS     r0,#0
000382  490b              LDR      r1,|L13.944|
000384  7008              STRB     r0,[r1,#0]
;;;298            if (final_stop)                                                 // If there is a final stop and no more jobs, bus is inactive, disable interrupts to prevent BTF
000386  480e              LDR      r0,|L13.960|
000388  7800              LDRB     r0,[r0,#0]  ; final_stop
00038a  b130              CBZ      r0,|L13.922|
;;;299                I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);       // Disable EVT and ERR interrupts while bus inactive
00038c  2200              MOVS     r2,#0
00038e  f44f7140          MOV      r1,#0x300
000392  4804              LDR      r0,|L13.932|
000394  6800              LDR      r0,[r0,#0]  ; I2Cx
000396  f7fffffe          BL       I2C_ITConfig
                  |L13.922|
;;;300            busy = FALSE;
00039a  2000              MOVS     r0,#0
00039c  490c              LDR      r1,|L13.976|
00039e  7008              STRB     r0,[r1,#0]
                  |L13.928|
;;;301        }
;;;302    }
0003a0  bd10              POP      {r4,pc}
;;;303    
                          ENDP

0003a2  0000              DCW      0x0000
                  |L13.932|
                          DCD      I2Cx
                  |L13.936|
                          DCD      index
                  |L13.940|
                          DCD      reading
                  |L13.944|
                          DCD      subaddress_sent
                  |L13.948|
                          DCD      ||reg||
                  |L13.952|
                          DCD      bytes
                  |L13.956|
                          DCD      addr
                  |L13.960|
                          DCD      final_stop
                  |L13.964|
                          DCD      read_p
                  |L13.968|
                          DCD      writing
                  |L13.972|
                          DCD      write_p
                  |L13.976|
                          DCD      busy

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  i2cHardwareMap
                          DCD      0x40005400
                          DCD      0x40010c00
000008  00400080          DCW      0x0040,0x0080
00000c  1f200000          DCB      0x1f,0x20,0x00,0x00
                          DCD      0x00200000
                          DCD      0x40005800
                          DCD      0x40010c00
00001c  04000800          DCW      0x0400,0x0800
000020  21220000          DCB      0x21,0x22,0x00,0x00
                          DCD      0x00400000

                          AREA ||.data||, DATA, ALIGN=2

                  I2Cx
                          DCD      0x00000000
                  I2Cx_index
000004  0000              DCB      0x00,0x00
                  i2cErrorCount
000006  0000              DCW      0x0000
                  error
000008  00                DCB      0x00
                  busy
000009  00                DCB      0x00
                  addr
00000a  00                DCB      0x00
                  ||reg||
00000b  00                DCB      0x00
                  bytes
00000c  00                DCB      0x00
                  writing
00000d  00                DCB      0x00
                  reading
00000e  0000              DCB      0x00,0x00
                  write_p
                          DCD      0x00000000
                  read_p
                          DCD      0x00000000
                  subaddress_sent
000018  00                DCB      0x00
                  final_stop
000019  00                DCB      0x00
                  index
00001a  00                DCB      0x00
