; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_istr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usb_istr.crf ..\..\User\usb_virture_com\usb_istr.c]
                          THUMB

                          AREA ||i.usb_Istr||, CODE, READONLY, ALIGN=2

                  usb_Istr PROC
;;;62     */
;;;63     void usb_Istr(void)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65     	wIstr = _GetISTR();
000002  4818              LDR      r0,|L1.100|
000004  6800              LDR      r0,[r0,#0]
000006  4918              LDR      r1,|L1.104|
000008  8008              STRH     r0,[r1,#0]
;;;66     
;;;67     #if (IMR_MSK & ISTR_CTR)
;;;68     	if (wIstr & ISTR_CTR & wInterrupt_Mask)
00000a  4608              MOV      r0,r1
00000c  8800              LDRH     r0,[r0,#0]  ; wIstr
00000e  f4004000          AND      r0,r0,#0x8000
000012  4916              LDR      r1,|L1.108|
000014  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000016  4008              ANDS     r0,r0,r1
000018  b108              CBZ      r0,|L1.30|
;;;69     	{
;;;70     		/* servicing of the endpoint correct transfer interrupt */
;;;71     		/* clear of the CTR flag into the sub */
;;;72     		CTR_LP();
00001a  f7fffffe          BL       CTR_LP
                  |L1.30|
;;;73     	#ifdef CTR_CALLBACK
;;;74     	    CTR_Callback();
;;;75     	#endif
;;;76       	}
;;;77     #endif  
;;;78     
;;;79     	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;80     #if (IMR_MSK & ISTR_RESET)
;;;81     	if (wIstr & ISTR_RESET & wInterrupt_Mask)
00001e  4812              LDR      r0,|L1.104|
000020  8800              LDRH     r0,[r0,#0]  ; wIstr
000022  f4006080          AND      r0,r0,#0x400
000026  4911              LDR      r1,|L1.108|
000028  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
00002a  4008              ANDS     r0,r0,r1
00002c  b130              CBZ      r0,|L1.60|
;;;82     	{
;;;83     		_SetISTR((uint16_t)CLR_RESET);
00002e  f64f30ff          MOV      r0,#0xfbff
000032  490c              LDR      r1,|L1.100|
000034  6008              STR      r0,[r1,#0]
;;;84     		Device_Property.Reset();
000036  490e              LDR      r1,|L1.112|
000038  6848              LDR      r0,[r1,#4]  ; Device_Property
00003a  4780              BLX      r0
                  |L1.60|
;;;85     	#ifdef RESET_CALLBACK
;;;86     		RESET_Callback();
;;;87     	#endif
;;;88     	}
;;;89     #endif
;;;90     
;;;91     	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;92     #if (IMR_MSK & ISTR_DOVR)
;;;93     	if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;94     	{
;;;95     		_SetISTR((uint16_t)CLR_DOVR);
;;;96     	#ifdef DOVR_CALLBACK
;;;97     		DOVR_Callback();
;;;98     	#endif
;;;99     	}
;;;100    #endif
;;;101    
;;;102    	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;103    #if (IMR_MSK & ISTR_ERR)
;;;104    	if (wIstr & ISTR_ERR & wInterrupt_Mask)
;;;105    	{
;;;106    		_SetISTR((uint16_t)CLR_ERR);
;;;107    	#ifdef ERR_CALLBACK
;;;108    		ERR_Callback();
;;;109    	#endif
;;;110    	}
;;;111    #endif
;;;112    
;;;113    	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;114    #if (IMR_MSK & ISTR_WKUP)
;;;115    	if (wIstr & ISTR_WKUP & wInterrupt_Mask)
;;;116    	{
;;;117    		_SetISTR((uint16_t)CLR_WKUP);
;;;118    		Resume(RESUME_EXTERNAL);
;;;119    	#ifdef WKUP_CALLBACK
;;;120    		WKUP_Callback();
;;;121    	#endif
;;;122    	}
;;;123    #endif
;;;124      
;;;125    	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;126    #if (IMR_MSK & ISTR_SUSP)
;;;127    	if (wIstr & ISTR_SUSP & wInterrupt_Mask)
;;;128    	{
;;;129    		/* check if SUSPEND is possible */
;;;130    		if (fSuspendEnabled)
;;;131    		{
;;;132    			Suspend();
;;;133    		}
;;;134    		else
;;;135    		{
;;;136    			/* if not possible then resume after xx ms */
;;;137    			Resume(RESUME_LATER);
;;;138    		}
;;;139    		
;;;140    		/* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;141    		_SetISTR((uint16_t)CLR_SUSP);
;;;142    	#ifdef SUSP_CALLBACK
;;;143    		SUSP_Callback();
;;;144    	#endif
;;;145    	}
;;;146    #endif
;;;147    
;;;148    	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;149    #if (IMR_MSK & ISTR_SOF)
;;;150    	if (wIstr & ISTR_SOF & wInterrupt_Mask)
00003c  480a              LDR      r0,|L1.104|
00003e  8800              LDRH     r0,[r0,#0]  ; wIstr
000040  f4007000          AND      r0,r0,#0x200
000044  4909              LDR      r1,|L1.108|
000046  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000048  4008              ANDS     r0,r0,r1
00004a  b150              CBZ      r0,|L1.98|
;;;151    	{
;;;152    		_SetISTR((uint16_t)CLR_SOF);
00004c  f64f50ff          MOV      r0,#0xfdff
000050  4904              LDR      r1,|L1.100|
000052  6008              STR      r0,[r1,#0]
;;;153    		bIntPackSOF++;
000054  4807              LDR      r0,|L1.116|
000056  7800              LDRB     r0,[r0,#0]  ; bIntPackSOF
000058  1c40              ADDS     r0,r0,#1
00005a  4906              LDR      r1,|L1.116|
00005c  7008              STRB     r0,[r1,#0]
;;;154    		
;;;155    	#ifdef SOF_CALLBACK
;;;156    		SOF_Callback();
00005e  f7fffffe          BL       SOF_Callback
                  |L1.98|
;;;157    	#endif
;;;158    	}
;;;159    #endif
;;;160    
;;;161    	/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;162    #if (IMR_MSK & ISTR_ESOF)
;;;163    	if (wIstr & ISTR_ESOF & wInterrupt_Mask)
;;;164    	{
;;;165    		_SetISTR((uint16_t)CLR_ESOF);
;;;166    		/* resume handling timing is made with ESOFs */
;;;167    		Resume(RESUME_ESOF); /* request without change of the machine state */
;;;168    	
;;;169    	#ifdef ESOF_CALLBACK
;;;170    		ESOF_Callback();
;;;171    	#endif
;;;172    	}
;;;173    #endif
;;;174    }
000062  bd10              POP      {r4,pc}
                          ENDP

                  |L1.100|
                          DCD      0x40005c44
                  |L1.104|
                          DCD      wIstr
                  |L1.108|
                          DCD      wInterrupt_Mask
                  |L1.112|
                          DCD      Device_Property
                  |L1.116|
                          DCD      bIntPackSOF

                          AREA ||.data||, DATA, ALIGN=2

                  wIstr
000000  0000              DCB      0x00,0x00
                  bIntPackSOF
000002  0000              DCB      0x00,0x00
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      EP3_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
