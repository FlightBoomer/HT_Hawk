; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_it.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -I..\..\User\Algorithm\ekf2 -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\stm32f10x_it.crf ..\..\User\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;136    */    
;;;137    void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;138    {
;;;139      /* 当总线异常时进入死循环 */
;;;140      while (1)
000002  e7fe              B        |L1.2|
;;;141      {
;;;142      }
;;;143    }
;;;144    
                          ENDP


                          AREA ||i.DMA1_Channel4_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Channel4_IRQHandler PROC
;;;70     //串口1  DMA方式发送中断  
;;;71     void DMA1_Channel4_IRQHandler(void)  
000000  b510              PUSH     {r4,lr}
;;;72     {   
;;;73       //清除标志位  
;;;74        DMA_ClearFlag(DMA1_FLAG_TC4);   
000002  f44f5000          MOV      r0,#0x2000
000006  f7fffffe          BL       DMA_ClearFlag
;;;75     	 Flag_Uart_Send=0;                    
00000a  2000              MOVS     r0,#0
00000c  4901              LDR      r1,|L2.20|
00000e  7008              STRB     r0,[r1,#0]
;;;76     } 
000010  bd10              POP      {r4,pc}
;;;77     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      Flag_Uart_Send

                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;180    */   
;;;181    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;182    {
;;;183    }
;;;184    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;104    */ 
;;;105    void HardFault_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;106    {
;;;107      /* 当硬件失效异常发生时进入死循环 */
;;;108      while (1)
000002  e7fe              B        |L4.2|
;;;109      {
;;;110      }
;;;111    }
;;;112    
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;120    */   
;;;121    void MemManage_Handler(void)
000000  bf00              NOP      
                  |L5.2|
;;;122    {
;;;123      /* 当内存管理异常发生时进入死循环 */
;;;124      while (1)
000002  e7fe              B        |L5.2|
;;;125      {
;;;126      }
;;;127    }
;;;128    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;92     */  
;;;93     void NMI_Handler(void)
000000  4770              BX       lr
;;;94     {
;;;95     }
;;;96     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;192    */     
;;;193    void PendSV_Handler(void)
000000  4770              BX       lr
;;;194    {
;;;195    }
;;;196    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;168    */   
;;;169    void SVC_Handler(void)
000000  4770              BX       lr
;;;170    {
;;;171    }
;;;172    
                          ENDP


                          AREA ||i.TIM5_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM5_IRQHandler PROC
;;;1      #ifndef __INCLUDE_H
;;;14     void TIM5_IRQHandler(void)		    //2.5ms中断一次
000000  b510              PUSH     {r4,lr}
;;;15     {	
;;;16     	if(TIM5->SR & TIM_IT_Update)	{    
000002  4816              LDR      r0,|L9.92|
000004  8800              LDRH     r0,[r0,#0]
000006  f0000001          AND      r0,r0,#1
00000a  b330              CBZ      r0,|L9.90|
;;;17         TIM5->SR = ~TIM_FLAG_Update;//清除中断标志	
00000c  f64f70fe          MOV      r0,#0xfffe
000010  4912              LDR      r1,|L9.92|
000012  8008              STRH     r0,[r1,#0]
;;;18        //以下代码执行1920us
;;;19     		realtime++;
000014  f04f517e          MOV      r1,#0x3f800000
000018  4811              LDR      r0,|L9.96|
00001a  6800              LDR      r0,[r0,#0]  ; realtime
00001c  f7fffffe          BL       __aeabi_fadd
000020  490f              LDR      r1,|L9.96|
000022  6008              STR      r0,[r1,#0]  ; realtime
;;;20     
;;;21      		testtime=TIM5->CNT;
000024  480d              LDR      r0,|L9.92|
000026  3014              ADDS     r0,r0,#0x14
000028  8800              LDRH     r0,[r0,#0]
00002a  490e              LDR      r1,|L9.100|
00002c  8008              STRH     r0,[r1,#0]
;;;22     		Time_slice();//2us		
00002e  f7fffffe          BL       Time_slice
;;;23     		RDAU();//62us对接收的遥控通道值进行处理，包含解锁、校准等动作解析	
000032  f7fffffe          BL       RDAU
;;;24     		AHRS_Geteuler();//1650us，其中地磁占用310us		
000036  f7fffffe          BL       AHRS_Geteuler
;;;25     		Calculate_Target();	//5us
00003a  f7fffffe          BL       Calculate_Target
;;;26     		Altitute_calculate();//180+200us			
00003e  f7fffffe          BL       Altitute_calculate
;;;27     		CONTROL(Target);//65us
000042  4809              LDR      r0,|L9.104|
000044  c80f              LDM      r0,{r0-r3}
000046  f7fffffe          BL       CONTROL
;;;28      	  testtime=TIM5->CNT-testtime;  
00004a  4804              LDR      r0,|L9.92|
00004c  3014              ADDS     r0,r0,#0x14
00004e  8800              LDRH     r0,[r0,#0]
000050  4904              LDR      r1,|L9.100|
000052  8809              LDRH     r1,[r1,#0]  ; testtime
000054  1a40              SUBS     r0,r0,r1
000056  4903              LDR      r1,|L9.100|
000058  8008              STRH     r0,[r1,#0]
                  |L9.90|
;;;29     	}
;;;30     }
00005a  bd10              POP      {r4,pc}
;;;31     
                          ENDP

                  |L9.92|
                          DCD      0x40000c10
                  |L9.96|
                          DCD      realtime
                  |L9.100|
                          DCD      testtime
                  |L9.104|
                          DCD      Target

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;37     
;;;38     void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;39     {
;;;40     	u8 com_data;
;;;41     	
;;;42     //	if(USART1->SR & USART_SR_ORE)//ORE中断
;;;43     //	{
;;;44     //		com_data = USART1->DR;
;;;45     //	}
;;;46     
;;;47       //接收中断
;;;48     	if( USART_GetITStatus(USART1,USART_IT_RXNE) )
000002  f2405125          MOV      r1,#0x525
000006  4810              LDR      r0,|L10.72|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b180              CBZ      r0,|L10.48|
;;;49     	{
;;;50     		USART_ClearITPendingBit(USART1,USART_IT_RXNE);//清除中断标志
00000e  f2405125          MOV      r1,#0x525
000012  480d              LDR      r0,|L10.72|
000014  f7fffffe          BL       USART_ClearITPendingBit
;;;51     
;;;52     		com_data = USART1->DR;
000018  480b              LDR      r0,|L10.72|
00001a  1d00              ADDS     r0,r0,#4
00001c  8800              LDRH     r0,[r0,#0]
00001e  b2c4              UXTB     r4,r0
;;;53     		Rx_Buf[Rxcounter++]=com_data;
000020  480a              LDR      r0,|L10.76|
000022  7801              LDRB     r1,[r0,#0]  ; Rxcounter
000024  7800              LDRB     r0,[r0,#0]  ; Rxcounter
000026  1c40              ADDS     r0,r0,#1
000028  4a08              LDR      r2,|L10.76|
00002a  7010              STRB     r0,[r2,#0]
00002c  4808              LDR      r0,|L10.80|
00002e  5444              STRB     r4,[r0,r1]
                  |L10.48|
;;;54     	}
;;;55     	
;;;56     	//发送（进入移位）中断，不使用，其实没有打开发送中断的。
;;;57     	if( USART_GetITStatus(USART1,USART_IT_TXE ) )
000030  f2407127          MOV      r1,#0x727
000034  4804              LDR      r0,|L10.72|
000036  f7fffffe          BL       USART_GetITStatus
00003a  b120              CBZ      r0,|L10.70|
;;;58     	{
;;;59     /*这里是采用发送移位中断才需要*/				
;;;60     //		USART1->DR = TxBuffer[TxCounter++]; //写DR清除中断标志          
;;;61     //		if(TxCounter == count)
;;;62     //		{
;;;63     //			USART1->CR1 &= ~USART_CR1_TXEIE;		//关闭TXE（发送中断）中断
;;;64     //		}
;;;65     		USART_ClearITPendingBit(USART1,USART_IT_TXE);//清除发送中断标志
00003c  f2407127          MOV      r1,#0x727
000040  4801              LDR      r0,|L10.72|
000042  f7fffffe          BL       USART_ClearITPendingBit
                  |L10.70|
;;;66     	}
;;;67     }
000046  bd10              POP      {r4,pc}
;;;68     
                          ENDP

                  |L10.72|
                          DCD      0x40013800
                  |L10.76|
                          DCD      Rxcounter
                  |L10.80|
                          DCD      Rx_Buf

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=1

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;226    extern void usb_Istr(void);
;;;227    void USB_LP_CAN1_RX0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;228    {
;;;229    	usb_Istr();
000002  f7fffffe          BL       usb_Istr
;;;230    }
000006  bd10              POP      {r4,pc}
;;;231    
                          ENDP


                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;152    */   
;;;153    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L12.2|
;;;154    {
;;;155      /* 当用法异常时进入死循环 */
;;;156      while (1)
000002  e7fe              B        |L12.2|
;;;157      {
;;;158      }
;;;159    }
;;;160    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  TxBuffer
                          %        256
                  Rx_Buf
                          %        256

                          AREA ||.data||, DATA, ALIGN=0

                  TxCounter
000000  00                DCB      0x00
                  count
000001  00                DCB      0x00
                  Rxcounter
000002  00                DCB      0x00
                  count_rx
000003  00                DCB      0x00
