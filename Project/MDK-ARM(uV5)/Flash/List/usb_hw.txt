; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_hw.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_hw.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -IC:\__Electronic_Projects\STM32\HT_Hawk_0528_1\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usb_hw.crf ..\..\User\usb_virture_com\usb_hw.c]
                          THUMB

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;211    */
;;;212    void Get_SerialNum(uint8_t *_pBuf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;213    {
000004  4604              MOV      r4,r0
;;;214    	uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;215    	
;;;216    	Device_Serial0 = *(__IO uint32_t*)(0x1FFFF7E8);
000006  480a              LDR      r0,|L1.48|
000008  6805              LDR      r5,[r0,#0]
;;;217    	Device_Serial1 = *(__IO uint32_t*)(0x1FFFF7EC);
00000a  1d00              ADDS     r0,r0,#4
00000c  6806              LDR      r6,[r0,#0]
;;;218    	Device_Serial2 = *(__IO uint32_t*)(0x1FFFF7F0);
00000e  1d00              ADDS     r0,r0,#4
000010  6807              LDR      r7,[r0,#0]
;;;219    	
;;;220    	Device_Serial0 += Device_Serial2;
000012  443d              ADD      r5,r5,r7
;;;221    	
;;;222    	if (Device_Serial0 != 0)
000014  b155              CBZ      r5,|L1.44|
;;;223    	{
;;;224    		IntToUnicode (Device_Serial0, &_pBuf[2] , 8);
000016  2208              MOVS     r2,#8
000018  1ca1              ADDS     r1,r4,#2
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       IntToUnicode
;;;225    		IntToUnicode (Device_Serial1, &_pBuf[18], 4);
000020  2204              MOVS     r2,#4
000022  f1040112          ADD      r1,r4,#0x12
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       IntToUnicode
                  |L1.44|
;;;226    	}
;;;227    }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;228    
                          ENDP

                  |L1.48|
                          DCD      0x1ffff7e8

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;238    */
;;;239    static void IntToUnicode (uint32_t _ulValue , uint8_t *_pBuf , uint8_t _ucLen)
000000  b530              PUSH     {r4,r5,lr}
;;;240    {
000002  460b              MOV      r3,r1
;;;241    	uint8_t idx = 0;
000004  2100              MOVS     r1,#0
;;;242    	
;;;243    	for( idx = 0 ; idx < _ucLen ; idx ++)
000006  bf00              NOP      
000008  e016              B        |L2.56|
                  |L2.10|
;;;244    	{
;;;245    		if( ((_ulValue >> 28)) < 0xA )
00000a  240a              MOVS     r4,#0xa
00000c  ebb47f10          CMP      r4,r0,LSR #28
000010  d905              BLS      |L2.30|
;;;246    		{
;;;247    			_pBuf[2 * idx] = (_ulValue >> 28) + '0';
000012  2430              MOVS     r4,#0x30
000014  eb047410          ADD      r4,r4,r0,LSR #28
000018  f8034011          STRB     r4,[r3,r1,LSL #1]
00001c  e005              B        |L2.42|
                  |L2.30|
;;;248    		}
;;;249    		else
;;;250    		{
;;;251    			_pBuf[2 * idx] = (_ulValue >> 28) + 'A' - 10; 
00001e  2441              MOVS     r4,#0x41
000020  eb047410          ADD      r4,r4,r0,LSR #28
000024  3c0a              SUBS     r4,r4,#0xa
000026  f8034011          STRB     r4,[r3,r1,LSL #1]
                  |L2.42|
;;;252    		}
;;;253    		
;;;254    		_ulValue = _ulValue << 4;
00002a  0100              LSLS     r0,r0,#4
;;;255    		
;;;256    		_pBuf[ 2 * idx + 1] = 0;
00002c  2500              MOVS     r5,#0
00002e  004c              LSLS     r4,r1,#1
000030  1c64              ADDS     r4,r4,#1
000032  551d              STRB     r5,[r3,r4]
000034  1c4c              ADDS     r4,r1,#1              ;243
000036  b2e1              UXTB     r1,r4                 ;243
                  |L2.56|
000038  4291              CMP      r1,r2                 ;243
00003a  dbe6              BLT      |L2.10|
;;;257    	}
;;;258    }
00003c  bd30              POP      {r4,r5,pc}
;;;259    
                          ENDP


                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;986     */
;;;987    static __INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;988    {
;;;989      register uint32_t __regPriMask         __ASM("primask");
;;;990      __regPriMask = (priMask);
;;;991    }
000004  4770              BX       lr
;;;992    
                          ENDP


                          AREA ||i.bsp_InitUsb||, CODE, READONLY, ALIGN=2

                  bsp_InitUsb PROC
;;;43     */
;;;44     void bsp_InitUsb(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;45     {
;;;46     	GPIO_InitTypeDef GPIO_InitStructure;
;;;47     	
;;;48     	/* 使能控制USB上拉电阻GPIO的时钟 */
;;;49     	RCC_APB2PeriphClockCmd(RCC_USB_PULL_UP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;50     	
;;;51     	/* 配置 USB 上拉引脚 */
;;;52     	USB_CABLE_DISABLE();	/* 断开USB设备 */
00000a  f44f7180          MOV      r1,#0x100
00000e  481a              LDR      r0,|L4.120|
000010  f7fffffe          BL       GPIO_SetBits
;;;53     	GPIO_InitStructure.GPIO_Pin = PIN_USB_PULL_UP;
000014  f44f7080          MOV      r0,#0x100
000018  f8ad0004          STRH     r0,[sp,#4]
;;;54     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0006          STRB     r0,[sp,#6]
;;;55     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000022  2014              MOVS     r0,#0x14
000024  f88d0007          STRB     r0,[sp,#7]
;;;56     	GPIO_Init(PORT_USB_PULL_UP, &GPIO_InitStructure);
000028  a901              ADD      r1,sp,#4
00002a  4813              LDR      r0,|L4.120|
00002c  f7fffffe          BL       GPIO_Init
;;;57     
;;;58     	/* 设置USB时钟源 */
;;;59     	RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       RCC_USBCLKConfig
;;;60     	
;;;61     	/* 使能USB时钟 */
;;;62     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000036  2101              MOVS     r1,#1
000038  05c8              LSLS     r0,r1,#23
00003a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;63     	
;;;64     	/* 配置USB中断 */
;;;65     	{
;;;66     		NVIC_InitTypeDef NVIC_InitStructure;
;;;67     		
;;;68     		NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00003e  f44f60a0          MOV      r0,#0x500
000042  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;69     		
;;;70     		NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
000046  2014              MOVS     r0,#0x14
000048  f88d0000          STRB     r0,[sp,#0]
;;;71     		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00004c  2001              MOVS     r0,#1
00004e  f88d0001          STRB     r0,[sp,#1]
;;;72     		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000052  2000              MOVS     r0,#0
000054  f88d0002          STRB     r0,[sp,#2]
;;;73     		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000058  2001              MOVS     r0,#1
00005a  f88d0003          STRB     r0,[sp,#3]
;;;74     		NVIC_Init(&NVIC_InitStructure);
00005e  4668              MOV      r0,sp
000060  f7fffffe          BL       NVIC_Init
;;;75     		
;;;76     		#if 0	/* 根据需要使能中断:USB从挂起状态到恢复 */
;;;77     		{
;;;78     			EXTI_InitTypeDef EXTI_InitStructure;
;;;79     			
;;;80     			/* 配置外部中断线18连接到USB IP中断(CPU内部连接) */
;;;81     			EXTI_ClearITPendingBit(EXTI_Line18);
;;;82     			EXTI_InitStructure.EXTI_Line = EXTI_Line18; /* USB从挂起状态到恢复 */
;;;83     			EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
;;;84     			EXTI_InitStructure.EXTI_LineCmd = ENABLE;
;;;85     			EXTI_Init(&EXTI_InitStructure);
;;;86     		}
;;;87     		#endif
;;;88     	}
;;;89     
;;;90     	g_tUsbFifo.usRxWrite = 0;
000064  2100              MOVS     r1,#0
000066  4805              LDR      r0,|L4.124|
000068  80c1              STRH     r1,[r0,#6]
;;;91     	g_tUsbFifo.usRxRead = 0;
00006a  8081              STRH     r1,[r0,#4]
;;;92     	g_tUsbFifo.usTxWrite = 0;
00006c  8041              STRH     r1,[r0,#2]
;;;93     	g_tUsbFifo.usTxRead = 0;
00006e  8001              STRH     r1,[r0,#0]
;;;94     
;;;95     	USB_Init();	
000070  f7fffffe          BL       USB_Init
;;;96     }
000074  bd1c              POP      {r2-r4,pc}
;;;97     
                          ENDP

000076  0000              DCW      0x0000
                  |L4.120|
                          DCD      0x40010800
                  |L4.124|
                          DCD      g_tUsbFifo+0x1000

                          AREA ||i.exeplay_write_appmask||, CODE, READONLY, ALIGN=2

                  exeplay_write_appmask PROC
;;;269    */
;;;270    void exeplay_write_appmask(u16 val)
000000  4909              LDR      r1,|L5.40|
;;;271    {
;;;272      RCC->APB1ENR|=1<<28;  	//使能电源时钟	    
000002  69c9              LDR      r1,[r1,#0x1c]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  4a07              LDR      r2,|L5.40|
00000a  61d1              STR      r1,[r2,#0x1c]
;;;273    	RCC->APB1ENR|=1<<27; 	//使能备份时钟	    
00000c  4611              MOV      r1,r2
00000e  69c9              LDR      r1,[r1,#0x1c]
000010  f0416100          ORR      r1,r1,#0x8000000
000014  61d1              STR      r1,[r2,#0x1c]
;;;274    	PWR->CR|=1<<8;      	//取消备份区写保护 
000016  4905              LDR      r1,|L5.44|
000018  6809              LDR      r1,[r1,#0]
00001a  f4417180          ORR      r1,r1,#0x100
00001e  4a03              LDR      r2,|L5.44|
000020  6011              STR      r1,[r2,#0]
;;;275    	BKP->DR2=val;			//标记要要写入标志值
000022  4903              LDR      r1,|L5.48|
000024  8008              STRH     r0,[r1,#0]
;;;276    }
000026  4770              BX       lr
;;;277    /*
                          ENDP

                  |L5.40|
                          DCD      0x40021000
                  |L5.44|
                          DCD      0x40007000
                  |L5.48|
                          DCD      0x40006c08

                          AREA ||i.usb_CableConfig||, CODE, READONLY, ALIGN=2

                  usb_CableConfig PROC
;;;176    */
;;;177    void usb_CableConfig(uint8_t _ucMode)
000000  b510              PUSH     {r4,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179    	if (_ucMode == DISABLE)
000004  b92c              CBNZ     r4,|L6.18|
;;;180    	{
;;;181    		USB_CABLE_DISABLE();	/* 断开USB设备 */
000006  f44f7180          MOV      r1,#0x100
00000a  4805              LDR      r0,|L6.32|
00000c  f7fffffe          BL       GPIO_SetBits
000010  e004              B        |L6.28|
                  |L6.18|
;;;182    	}
;;;183    	else
;;;184    	{
;;;185    		USB_CABLE_ENABLE();		/* 连接USB设备, 实质上将D+上拉，此时USB设备就能被集线器检测到了 */
000012  f44f7180          MOV      r1,#0x100
000016  4802              LDR      r0,|L6.32|
000018  f7fffffe          BL       GPIO_ResetBits
                  |L6.28|
;;;186    	}
;;;187    }
00001c  bd10              POP      {r4,pc}
;;;188    				   
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40010800

                          AREA ||i.usb_EnterLowPowerMode||, CODE, READONLY, ALIGN=2

                  usb_EnterLowPowerMode PROC
;;;105    */
;;;106    void usb_EnterLowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;107    {
;;;108    	/* 设置设备状态为 suspend, bDeviceState 全局变量在 usb_pwr.c 中定义 */
;;;109    	bDeviceState = SUSPENDED;
000002  4901              LDR      r1,|L7.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;110    
;;;111    	#if 0	/* 根据需要关闭电源 （鼠标键盘设备可进入挂起状态，虚拟串口等设备最好保持常开） */
;;;112    		/* 清 EXTI Line18 中断标志 */
;;;113    		EXTI_ClearITPendingBit(EXTI_Line8);
;;;114    		
;;;115    		/* 在低功耗状态，关闭电压调节器 */
;;;116    		PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI);	
;;;117    	#endif
;;;118    }
000006  4770              BX       lr
;;;119    
                          ENDP

                  |L7.8|
                          DCD      bDeviceState

                          AREA ||i.usb_GetRxByte||, CODE, READONLY, ALIGN=2

                  usb_GetRxByte PROC
;;;331    */
;;;332    uint8_t usb_GetRxByte(uint8_t *_pByteNum)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334    	uint8_t ucData;
;;;335    	uint16_t usRxWrite;
;;;336    	
;;;337    	__set_PRIMASK(1);  		/* 关中断，避免USB中断程序和主程序访问变量冲突 */
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       __set_PRIMASK
;;;338    	usRxWrite = g_tUsbFifo.usRxWrite;
00000a  4810              LDR      r0,|L8.76|
00000c  88c6              LDRH     r6,[r0,#6]  ; g_tUsbFifo
;;;339    	__set_PRIMASK(0);  		/* 开中断 */
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;340    
;;;341    	/* 发送缓冲区为空时，返回字节数 = 0 */
;;;342    	if (g_tUsbFifo.usRxRead == usRxWrite)
000014  480d              LDR      r0,|L8.76|
000016  8880              LDRH     r0,[r0,#4]  ; g_tUsbFifo
000018  42b0              CMP      r0,r6
00001a  d102              BNE      |L8.34|
;;;343    	{
;;;344    		*_pByteNum = 0;
00001c  2000              MOVS     r0,#0
00001e  7020              STRB     r0,[r4,#0]
                  |L8.32|
;;;345    		return 0;
;;;346    	}
;;;347    	
;;;348    	/* 保存第1个字节 */
;;;349    	ucData = g_tUsbFifo.aRxBuf[g_tUsbFifo.usRxRead];
;;;350    	
;;;351    	/* 移动读指针 */
;;;352    	if (++g_tUsbFifo.usRxRead >= USB_RX_BUF_SIZE)
;;;353    	{
;;;354    		g_tUsbFifo.usRxRead = 0;
;;;355    	}
;;;356    
;;;357    	*_pByteNum = 1;		/* 有效字节个数 = 1 */
;;;358    	return ucData;		
;;;359    }
000020  bd70              POP      {r4-r6,pc}
                  |L8.34|
000022  480a              LDR      r0,|L8.76|
000024  8881              LDRH     r1,[r0,#4]            ;349  ; g_tUsbFifo
000026  f5a06000          SUB      r0,r0,#0x800          ;349
00002a  5c45              LDRB     r5,[r0,r1]            ;349
00002c  4807              LDR      r0,|L8.76|
00002e  8880              LDRH     r0,[r0,#4]            ;352  ; g_tUsbFifo
000030  1c40              ADDS     r0,r0,#1              ;352
000032  b281              UXTH     r1,r0                 ;352
000034  4805              LDR      r0,|L8.76|
000036  8081              STRH     r1,[r0,#4]            ;352
000038  f5b16f00          CMP      r1,#0x800             ;352
00003c  db01              BLT      |L8.66|
00003e  2100              MOVS     r1,#0                 ;354
000040  8081              STRH     r1,[r0,#4]            ;354
                  |L8.66|
000042  2001              MOVS     r0,#1                 ;357
000044  7020              STRB     r0,[r4,#0]            ;357
000046  4628              MOV      r0,r5                 ;358
000048  e7ea              B        |L8.32|
;;;360    
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      g_tUsbFifo+0x1000

                          AREA ||i.usb_GetTxWord||, CODE, READONLY, ALIGN=2

                  usb_GetTxWord PROC
;;;399    */
;;;400    uint16_t usb_GetTxWord(uint8_t *_pByteNum)
000000  4601              MOV      r1,r0
;;;401    {
;;;402    	uint16_t usData;
;;;403    	
;;;404    	/* 发送缓冲区为空时，返回字节数 = 0 */
;;;405    	if (g_tUsbFifo.usTxRead == g_tUsbFifo.usTxWrite)
000002  481b              LDR      r0,|L9.112|
000004  8803              LDRH     r3,[r0,#0]  ; g_tUsbFifo
000006  8840              LDRH     r0,[r0,#2]  ; g_tUsbFifo
000008  4283              CMP      r3,r0
00000a  d102              BNE      |L9.18|
;;;406    	{
;;;407    		*_pByteNum = 0;
00000c  2000              MOVS     r0,#0
00000e  7008              STRB     r0,[r1,#0]
                  |L9.16|
;;;408    		return 0;
;;;409    	}
;;;410    	
;;;411    	/* 保存第1个字节 */
;;;412    	usData = g_tUsbFifo.aTxBuf[g_tUsbFifo.usTxRead];
;;;413    	
;;;414    	/* 移动读指针 */
;;;415    	if (++g_tUsbFifo.usTxRead >= USB_TX_BUF_SIZE)
;;;416    	{
;;;417    		g_tUsbFifo.usTxRead = 0;
;;;418    	}
;;;419    	
;;;420    	/* 不足2字节，直接返回 */
;;;421    	if (g_tUsbFifo.usTxRead == g_tUsbFifo.usTxWrite)
;;;422    	{
;;;423    		*_pByteNum = 1;		/* 有效字节个数 = 1 */
;;;424    		return usData;
;;;425    	}	
;;;426    	
;;;427    	/* 保存第2个字节 */
;;;428    	usData += g_tUsbFifo.aTxBuf[g_tUsbFifo.usTxRead] << 8;
;;;429    
;;;430    	/* 移动读指针 */
;;;431    	if (++g_tUsbFifo.usTxRead >= USB_TX_BUF_SIZE)
;;;432    	{
;;;433    		g_tUsbFifo.usTxRead = 0;
;;;434    	}
;;;435    
;;;436    	*_pByteNum = 2;		/* 有效字节个数 = 2 */
;;;437    	return usData;		
;;;438    }
000010  4770              BX       lr
                  |L9.18|
000012  4817              LDR      r0,|L9.112|
000014  8800              LDRH     r0,[r0,#0]            ;412  ; g_tUsbFifo
000016  4b17              LDR      r3,|L9.116|
000018  5c1a              LDRB     r2,[r3,r0]            ;412
00001a  4815              LDR      r0,|L9.112|
00001c  8800              LDRH     r0,[r0,#0]            ;415  ; g_tUsbFifo
00001e  1c40              ADDS     r0,r0,#1              ;415
000020  b283              UXTH     r3,r0                 ;415
000022  4813              LDR      r0,|L9.112|
000024  8003              STRH     r3,[r0,#0]            ;415
000026  f5b36f00          CMP      r3,#0x800             ;415
00002a  db01              BLT      |L9.48|
00002c  2300              MOVS     r3,#0                 ;417
00002e  8003              STRH     r3,[r0,#0]            ;417
                  |L9.48|
000030  480f              LDR      r0,|L9.112|
000032  8803              LDRH     r3,[r0,#0]            ;421  ; g_tUsbFifo
000034  8840              LDRH     r0,[r0,#2]            ;421  ; g_tUsbFifo
000036  4283              CMP      r3,r0                 ;421
000038  d103              BNE      |L9.66|
00003a  2001              MOVS     r0,#1                 ;423
00003c  7008              STRB     r0,[r1,#0]            ;423
00003e  4610              MOV      r0,r2                 ;424
000040  e7e6              B        |L9.16|
                  |L9.66|
000042  480b              LDR      r0,|L9.112|
000044  8800              LDRH     r0,[r0,#0]            ;428  ; g_tUsbFifo
000046  4b0b              LDR      r3,|L9.116|
000048  5c18              LDRB     r0,[r3,r0]            ;428
00004a  eb022000          ADD      r0,r2,r0,LSL #8       ;428
00004e  b282              UXTH     r2,r0                 ;428
000050  4807              LDR      r0,|L9.112|
000052  8800              LDRH     r0,[r0,#0]            ;431  ; g_tUsbFifo
000054  1c40              ADDS     r0,r0,#1              ;431
000056  b283              UXTH     r3,r0                 ;431
000058  4805              LDR      r0,|L9.112|
00005a  8003              STRH     r3,[r0,#0]            ;431
00005c  f5b36f00          CMP      r3,#0x800             ;431
000060  db01              BLT      |L9.102|
000062  2300              MOVS     r3,#0                 ;433
000064  8003              STRH     r3,[r0,#0]            ;433
                  |L9.102|
000066  2002              MOVS     r0,#2                 ;436
000068  7008              STRB     r0,[r1,#0]            ;436
00006a  4610              MOV      r0,r2                 ;437
00006c  e7d0              B        |L9.16|
                          ENDP

00006e  0000              DCW      0x0000
                  |L9.112|
                          DCD      g_tUsbFifo+0x1000
                  |L9.116|
                          DCD      g_tUsbFifo

                          AREA ||i.usb_LeaveLowPowerMode||, CODE, READONLY, ALIGN=2

                  usb_LeaveLowPowerMode PROC
;;;127    */
;;;128    void usb_LeaveLowPowerMode(void)
000000  4805              LDR      r0,|L10.24|
;;;129    {
;;;130    	DEVICE_INFO *pInfo = &Device_Info;  /* 全局变量Device_Info 在USB固件库 usb_init.c 中定义 */	
;;;131    
;;;132    #if 0	/* 根据需要恢复系统时钟 */
;;;133    	/* 使能 HSE */
;;;134    	RCC_HSEConfig(RCC_HSE_ON);
;;;135    	
;;;136    	/* 等待 HSE 就绪 */
;;;137    	RCC_WaitForHSEStartUp();
;;;138    	
;;;139    	/* 使能 HSE */
;;;140    	RCC_HSEConfig(RCC_HSE_ON);
;;;141    	
;;;142    	/* 等待 HSE 就绪 */
;;;143    	while (RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);
;;;144    	
;;;145    	/* 使能PLL */
;;;146    	RCC_PLLCmd(ENABLE);
;;;147    	
;;;148    	/* 等待PLL就绪 */
;;;149    	while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
;;;150    	
;;;151    	/* 选择PLL作为系统时钟源 */
;;;152    	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
;;;153    	
;;;154    	/* 等待PLL系统时钟源稳定 */
;;;155    	while (RCC_GetSYSCLKSource() != 0x08);
;;;156    #endif
;;;157    	
;;;158    	/* 更新全局变量bDeviceState，表示usb设备状态 */
;;;159    	if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
000004  b119              CBZ      r1,|L10.14|
;;;160    	{
;;;161    		bDeviceState = CONFIGURED;	/* 配置成功 */
000006  2105              MOVS     r1,#5
000008  4a04              LDR      r2,|L10.28|
00000a  6011              STR      r1,[r2,#0]  ; bDeviceState
00000c  e002              B        |L10.20|
                  |L10.14|
;;;162    	}
;;;163    	else
;;;164    	{
;;;165    		bDeviceState = ATTACHED;	/* USB设备已连接，但还未配置 */
00000e  2101              MOVS     r1,#1
000010  4a02              LDR      r2,|L10.28|
000012  6011              STR      r1,[r2,#0]  ; bDeviceState
                  |L10.20|
;;;166    	}	
;;;167    }
000014  4770              BX       lr
;;;168    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      Device_Info
                  |L10.28|
                          DCD      bDeviceState

                          AREA ||i.usb_SaveHostDataToBuf||, CODE, READONLY, ALIGN=2

                  usb_SaveHostDataToBuf PROC
;;;286    */
;;;287    void usb_SaveHostDataToBuf(uint8_t *_pInBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;288    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;289    	uint16_t i;
;;;290    	u8 datacheck=0;
000006  2600              MOVS     r6,#0
;;;291    	
;;;292    	extern void delay_ms(u16 nms);
;;;293    	extern void STMFLASH_Write(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite);
;;;294    	if(_pInBuf[0]==0x8A)//这下大件事咯，要更新FLASH啊！PID修改工具上位机下发的更新FLASH命令
000008  7820              LDRB     r0,[r4,#0]
00000a  288a              CMP      r0,#0x8a
00000c  d13f              BNE      |L11.142|
;;;295    	if(_pInBuf[1]==0x5B)
00000e  7860              LDRB     r0,[r4,#1]
000010  285b              CMP      r0,#0x5b
000012  d13c              BNE      |L11.142|
;;;296    	if(_pInBuf[2]==0x1C)
000014  78a0              LDRB     r0,[r4,#2]
000016  281c              CMP      r0,#0x1c
000018  d139              BNE      |L11.142|
;;;297    	if(_pInBuf[3]==0xAC)
00001a  78e0              LDRB     r0,[r4,#3]
00001c  28ac              CMP      r0,#0xac
00001e  d136              BNE      |L11.142|
;;;298    	{
;;;299    					 
;;;300    		 for(i=0;i<4;i++)datacheck+=_pInBuf[i];
000020  2000              MOVS     r0,#0
000022  9000              STR      r0,[sp,#0]
000024  e009              B        |L11.58|
                  |L11.38|
000026  f8bd0000          LDRH     r0,[sp,#0]
00002a  5c20              LDRB     r0,[r4,r0]
00002c  4430              ADD      r0,r0,r6
00002e  b2c6              UXTB     r6,r0
000030  f8bd0000          LDRH     r0,[sp,#0]
000034  1c40              ADDS     r0,r0,#1
000036  b280              UXTH     r0,r0
000038  9000              STR      r0,[sp,#0]
                  |L11.58|
00003a  f8bd0000          LDRH     r0,[sp,#0]
00003e  2804              CMP      r0,#4
000040  dbf1              BLT      |L11.38|
;;;301    		 if(datacheck ==_pInBuf[4])
000042  7920              LDRB     r0,[r4,#4]
000044  42b0              CMP      r0,r6
000046  d122              BNE      |L11.142|
;;;302    			{
;;;303    				exeplay_write_appmask(0x5050);//写入要更新程序
000048  f2450050          MOV      r0,#0x5050
00004c  f7fffffe          BL       exeplay_write_appmask
;;;304    				i=0x0000;
000050  2000              MOVS     r0,#0
000052  9000              STR      r0,[sp,#0]
;;;305    				STMFLASH_Write(pro_FALG_ADD,&i,1);
000054  2201              MOVS     r2,#1
000056  4669              MOV      r1,sp
000058  481d              LDR      r0,|L11.208|
00005a  f7fffffe          BL       STMFLASH_Write
;;;306    				USB_CABLE_DISABLE();	/* 断开USB设备 */
00005e  f44f7180          MOV      r1,#0x100
000062  481c              LDR      r0,|L11.212|
000064  f7fffffe          BL       GPIO_SetBits
;;;307    				delay_ms(1500);    //1.5秒后复位
000068  f24050dc          MOV      r0,#0x5dc
00006c  f7fffffe          BL       delay_ms
;;;308    				NVIC_SystemReset();//软复位一下
000070  bf00              NOP      
000072  4819              LDR      r0,|L11.216|
000074  6800              LDR      r0,[r0,#0]
000076  f40060e0          AND      r0,r0,#0x700
00007a  4918              LDR      r1,|L11.220|
00007c  4308              ORRS     r0,r0,r1
00007e  1d00              ADDS     r0,r0,#4
000080  4915              LDR      r1,|L11.216|
000082  6008              STR      r0,[r1,#0]
000084  f3bf8f40          DSB      #0x0
000088  bf00              NOP      
00008a  bf00              NOP      
                  |L11.140|
00008c  e7fe              B        |L11.140|
                  |L11.142|
;;;309    			}
;;;310    		}
;;;311    	/* 未考虑缓冲区填满的情况 */
;;;312    	for (i = 0 ; i < _usLen; i++)
00008e  2000              MOVS     r0,#0
000090  9000              STR      r0,[sp,#0]
000092  e017              B        |L11.196|
                  |L11.148|
;;;313    	{
;;;314    		g_tUsbFifo.aRxBuf[g_tUsbFifo.usRxWrite] = _pInBuf[i];
000094  f8bd0000          LDRH     r0,[sp,#0]
000098  5c21              LDRB     r1,[r4,r0]
00009a  4811              LDR      r0,|L11.224|
00009c  88c2              LDRH     r2,[r0,#6]  ; g_tUsbFifo
00009e  f5a06000          SUB      r0,r0,#0x800
0000a2  5481              STRB     r1,[r0,r2]
;;;315    		
;;;316    		if (++g_tUsbFifo.usRxWrite >= USB_RX_BUF_SIZE)
0000a4  480e              LDR      r0,|L11.224|
0000a6  88c0              LDRH     r0,[r0,#6]  ; g_tUsbFifo
0000a8  1c40              ADDS     r0,r0,#1
0000aa  b281              UXTH     r1,r0
0000ac  480c              LDR      r0,|L11.224|
0000ae  80c1              STRH     r1,[r0,#6]
0000b0  f5b16f00          CMP      r1,#0x800
0000b4  db01              BLT      |L11.186|
;;;317    		{
;;;318    			g_tUsbFifo.usRxWrite = 0;
0000b6  2100              MOVS     r1,#0
0000b8  80c1              STRH     r1,[r0,#6]
                  |L11.186|
0000ba  f8bd0000          LDRH     r0,[sp,#0]            ;312
0000be  1c40              ADDS     r0,r0,#1              ;312
0000c0  b280              UXTH     r0,r0                 ;312
0000c2  9000              STR      r0,[sp,#0]            ;312
                  |L11.196|
0000c4  f8bd0000          LDRH     r0,[sp,#0]            ;312
0000c8  42a8              CMP      r0,r5                 ;312
0000ca  dbe3              BLT      |L11.148|
;;;319    		}
;;;320    	}
;;;321    }
0000cc  bdf8              POP      {r3-r7,pc}
;;;322    /*
                          ENDP

0000ce  0000              DCW      0x0000
                  |L11.208|
                          DCD      0x0801fff0
                  |L11.212|
                          DCD      0x40010800
                  |L11.216|
                          DCD      0xe000ed0c
                  |L11.220|
                          DCD      0x05fa0000
                  |L11.224|
                          DCD      g_tUsbFifo+0x1000

                          AREA ||i.usb_SendBuf||, CODE, READONLY, ALIGN=1

                  usb_SendBuf PROC
;;;196    */
;;;197    void usb_SendBuf(uint8_t *_pTxBuf, uint8_t _ucLen)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;199        UserToPMABufferCopy(_pTxBuf, ENDP1_TXADDR, _ucLen);
000006  4622              MOV      r2,r4
000008  21c0              MOVS     r1,#0xc0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       UserToPMABufferCopy
;;;200        SetEPTxCount(ENDP1, _ucLen);
000010  4621              MOV      r1,r4
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       SetEPTxCount
;;;201        SetEPTxValid(ENDP1); 
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       SetEPTxValid
;;;202    }
00001e  bd70              POP      {r4-r6,pc}
;;;203    
                          ENDP


                          AREA ||i.usb_SendDataToHost||, CODE, READONLY, ALIGN=2

                  usb_SendDataToHost PROC
;;;370    */
;;;371    void usb_SendDataToHost(uint8_t *_pTxBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;373    	uint16_t i;
;;;374    	
;;;375    	/* 未考虑缓冲区填满的情况 */
;;;376    	/* 先将数据缓存到内存 */
;;;377    	for (i = 0 ; i < _usLen; i++)
000006  2400              MOVS     r4,#0
000008  e017              B        |L13.58|
                  |L13.10|
;;;378    	{
;;;379    		g_tUsbFifo.aTxBuf[g_tUsbFifo.usTxWrite] = _pTxBuf[i];
00000a  5d29              LDRB     r1,[r5,r4]
00000c  480c              LDR      r0,|L13.64|
00000e  8840              LDRH     r0,[r0,#2]  ; g_tUsbFifo
000010  4a0c              LDR      r2,|L13.68|
000012  5411              STRB     r1,[r2,r0]
;;;380    
;;;381    		__set_PRIMASK(1);  		/* 关中断，避免USB中断程序和主程序访问 usTxWrite 变量冲突 */
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       __set_PRIMASK
;;;382    		
;;;383    		if (++g_tUsbFifo.usTxWrite >= USB_RX_BUF_SIZE)
00001a  4809              LDR      r0,|L13.64|
00001c  8840              LDRH     r0,[r0,#2]  ; g_tUsbFifo
00001e  1c40              ADDS     r0,r0,#1
000020  b281              UXTH     r1,r0
000022  4807              LDR      r0,|L13.64|
000024  8041              STRH     r1,[r0,#2]
000026  f5b16f00          CMP      r1,#0x800
00002a  db01              BLT      |L13.48|
;;;384    		{
;;;385    			g_tUsbFifo.usTxWrite = 0;
00002c  2100              MOVS     r1,#0
00002e  8041              STRH     r1,[r0,#2]
                  |L13.48|
;;;386    		}
;;;387    
;;;388    		__set_PRIMASK(0);  		/* 开中断 */
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       __set_PRIMASK
000036  1c60              ADDS     r0,r4,#1              ;377
000038  b284              UXTH     r4,r0                 ;377
                  |L13.58|
00003a  42b4              CMP      r4,r6                 ;377
00003c  dbe5              BLT      |L13.10|
;;;389    	}
;;;390    }
00003e  bd70              POP      {r4-r6,pc}
;;;391    
                          ENDP

                  |L13.64|
                          DCD      g_tUsbFifo+0x1000
                  |L13.68|
                          DCD      g_tUsbFifo

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tUsbFifo
                          %        4106
